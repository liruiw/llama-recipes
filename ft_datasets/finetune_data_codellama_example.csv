prompt,completion
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-box-corner"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-box-corner]. Provide answers in a python code block starting with ```python
","
```python
import os
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class AlignBoxCorner(Task):
    """"""Pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""align the brown box with the green corner""
        self.task_completed_desc = ""done with alignment""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Generate randomly shaped box.
        box_size = self.get_random_size(0.05, 0.15, 0.05, 0.15, 0.01, 0.06)

        # Add corner.
        dimx = (box_size[0] / 2 - 0.025 + 0.0025, box_size[0] / 2 + 0.0025)
        dimy = (box_size[1] / 2 + 0.0025, box_size[1] / 2 - 0.025 + 0.0025)
        corner_template = 'corner/corner-template.urdf'
        replace = {'DIMX': dimx, 'DIMY': dimy}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        corner_urdf = self.fill_template(corner_template, replace)
        corner_size = (box_size[0], box_size[1], 0)
        corner_pose = self.get_random_pose(env, corner_size)
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Add possible placing poses.
        theta = utils.quatXYZW_to_eulerXYZ(corner_pose[1])[2]
        fip_rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta + np.pi))
        pose1 = (corner_pose[0], fip_rot)
        alt_x = (box_size[0] / 2) - (box_size[1] / 2)
        alt_y = (box_size[1] / 2) - (box_size[0] / 2)
        alt_pos = (alt_x, alt_y, 0)
        alt_rot0 = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        alt_rot1 = utils.eulerXYZ_to_quatXYZW((0, 0, 3 * np.pi / 2))
        pose2 = utils.multiply(corner_pose, (alt_pos, alt_rot0))
        pose3 = utils.multiply(corner_pose, (alt_pos, alt_rot1))

        # Add box.
        box_template = 'box/box-template.urdf'

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        box_urdf = self.fill_template(box_template, {'DIM': np.float32(box_size)})
        box_pose = self.get_random_pose(env, box_size)
        box_id = env.add_object(box_urdf, box_pose)
        self.color_random_brown(box_id)

        # Goal: box is aligned with corner (1 of 4 possible poses).
        self.add_goal(objs=[box_id], matches=np.int32([[1, 1, 1, 1]]), targ_poses=[corner_pose, pose1, pose2, pose3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-rope"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-rope]. Provide answers in a python code block starting with ```python
","
```python
import os

import numpy as np
from cliport.tasks import primitives
from cliport.tasks.task import Task
from cliport.utils import utils

import random
import pybullet as p


class AlignRope(Task):
    """"""Manipulate a deformable rope to connect its end-points between two 
    corners of a 3-sided square.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope from {direction}""
        self.task_completed_desc = ""done aligning the rope.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square.
        square_size = (length, length, 0)
        square_pose = self.get_random_pose(env, square_size)
        square_template = 'square/square-template.urdf'
        replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        urdf = self.fill_template(square_template, replace)
        env.add_object(urdf, square_pose, 'fixed')

        # Get four corner points of square.
        corner0 = ( length / 2,  length / 2, 0.001)
        corner1 = (-length / 2,  length / 2, 0.001)
        corner2 = ( length / 2, -length / 2, 0.001)
        corner3 = (-length / 2, -length / 2, 0.001)

        corner0 = utils.apply(square_pose, corner0)
        corner1 = utils.apply(square_pose, corner1)
        corner2 = utils.apply(square_pose, corner2)
        corner3 = utils.apply(square_pose, corner3)
        
        # Four possible alignment tasks.
        task_descs = [
            ((corner0, corner1), ""front left tip to front right tip""),
            ((corner0, corner2), ""front right tip to back right corner""),
            ((corner1, corner3), ""front left tip to back left corner""),
            ((corner3, corner2), ""back right corner to back left corner"")
        ]
        chosen_task = np.random.choice(len(task_descs), 1)[0]
        (corner_0, corner_1), direction = task_descs[chosen_task]

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1))
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1.,
                language_goal=[self.lang_template.format(direction=direction)] * len(objects))

        # wait for the scene to settle down
        for i in range(480):
            p.stepSimulation()
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""assembling-kits"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [assembling-kits]. Provide answers in a python code block starting with ```python
","
```python
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class AssemblingKits(Task):
    """"""pick up different objects and arrange them on a board marked with corresponding silhouettes.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.homogeneous = False

        self.lang_template = ""put all the blocks inside the holes they fit in""
        self.task_completed_desc = ""done assembling blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add kit.
        kit_size = (0.28, 0.2, 0.005)
        kit_urdf = 'kitting/kit.urdf'
        kit_pose = self.get_random_pose(env, kit_size)
        env.add_object(kit_urdf, kit_pose, 'fixed')

        n_objects = 5
        obj_shapes = self.get_kitting_shapes(n_objects)
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['red']
        ]

        # Build kit.
        targets = []
        targ_pos = [[-0.09, 0.045, 0.0014], [0, 0.045, 0.0014],
                    [0.09, 0.045, 0.0014], [-0.045, -0.045, 0.0014],
                    [0.045, -0.045, 0.0014]]
        template = 'kitting/object-template.urdf'

        for i in range(n_objects):
            shape = os.path.join(self.assets_root, 'kitting',
                                 f'{obj_shapes[i]:02d}.obj')
            scale = [0.003, 0.003, 0.0001]  # .0005
            pos = utils.apply(kit_pose, targ_pos[i])
            theta = np.random.rand() * 2 * np.pi
            rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': [0.2, 0.2, 0.2]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            env.add_object(urdf, (pos, rot), 'fixed')
            targets.append((pos, rot))

        # Add objects.
        objects, matches = self.make_kitting_objects(env, targets=targets, obj_shapes=obj_shapes, n_objects=n_objects, colors=colors)
        matches = np.int32(matches)
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)
 
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""manipulating-rope"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [manipulating-rope]. Provide answers in a python code block starting with ```python
","
```python
import os

import numpy as np
from cliport.tasks import primitives
from cliport.tasks.task import Task
from cliport.utils import utils

import pybullet as p


class ManipulatingRope(Task):
    """"""rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""manipulate the rope to complete the square""
        self.task_completed_desc = ""done manipulating the rope.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square.
        square_size = (length, length, 0)
        square_pose = self.get_random_pose(env, square_size)
        square_template = 'square/square-template.urdf'

        # IMPORTANT: REPLACE THE TEMPLATE URDF  with `fill_template`
        replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}
        urdf = self.fill_template(square_template, replace)
        env.add_object(urdf, square_pose, 'fixed')

        # compute corners
        corner0 = (length / 2, length / 2, 0.001)
        corner1 = (-length / 2, length / 2, 0.001)
        corner_0 = utils.apply(square_pose, corner0)
        corner_1 = utils.apply(square_pose, corner1)

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1))
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1., lang_goal=self.lang_template)

        for i in range(480):
            p.stepSimulation()

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""packing-boxes"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [packing-boxes]. Provide answers in a python code block starting with ```python
","
```python
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

import pybullet as p


class PackingBoxes(Task):
    """"""pick up randomly sized boxes and place them tightly into a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""pack all the boxes inside the brown box""
        self.task_completed_desc = ""done packing boxes.""

        self.zone_bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.08]])
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container box.
        zone_size = self.get_random_size(0.05, 0.3, 0.05, 0.3, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        margin = 0.01
        min_object_dim = 0.05
        bboxes = []

        # Split container space with KD trees.
        stack_size = np.array(zone_size)
        stack_size[0] -= 0.01
        stack_size[1] -= 0.01
        root_size = (0.01, 0.01, 0) + tuple(stack_size)
        root = utils.TreeNode(None, [], bbox=np.array(root_size))
        utils.KDTree(root, min_object_dim, margin, bboxes)

        colors = [utils.COLORS[c] for c in utils.COLORS if c != 'brown']

        # Add objects in container.
        object_ids = []
        bboxes = np.array(bboxes)
        object_template = 'box/box-template.urdf'

        # Compute object points that are needed for zone
        for bbox in bboxes:
            size = bbox[3:] - bbox[:3]
            position = size / 2. + bbox[:3]
            position[0] += -zone_size[0] / 2
            position[1] += -zone_size[1] / 2
            pose = (position, (0, 0, 0, 1))
            pose = utils.multiply(zone_pose, pose)

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(object_template, {'DIM': size})
            icolor = np.random.choice(range(len(colors)), 1).squeeze()
            box_id = env.add_object(urdf, pose, color=colors[icolor])
            object_ids.append(box_id)

        # Randomly select object in box and save ground truth pose.
        object_volumes = []
        true_poses = []

        for object_id in object_ids:
            true_pose = p.getBasePositionAndOrientation(object_id)
            object_size = p.getVisualShapeData(object_id)[0][3]
            object_volumes.append(np.prod(np.array(object_size) * 100))
            pose = self.get_random_pose(env, object_size)
            p.resetBasePositionAndOrientation(object_id, pose[0], pose[1])
            true_poses.append(true_pose)

        self.add_goal(objs=object_ids, matches=np.eye(len(object_ids)), targ_poses=true_poses, replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""palletizing-boxes"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [palletizing-boxes]. Provide answers in a python code block starting with ```python
","
```python
import os
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PalletizingBoxes(Task):
    """"""Pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 30
        self.lang_template = ""stack all the boxes on the pallet""
        self.task_completed_desc = ""done stacking boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        zone_size = (0.3, 0.25, 0.25)
        zone_urdf = 'pallet/pallet.urdf'
        rotation = utils.eulerXYZ_to_quatXYZW((0, 0, 0))
        zone_pose = ((0.5, 0.25, 0.02), rotation)
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add stack of boxes on pallet.
        margin = 0.01
        object_ids = []

        # x, y, z dimensions for the asset size
        stack_size = (0.19, 0.19, 0.19)
        box_template = 'box/box-template.urdf'
        stack_dim = np.int32([2, 3, 3])

        box_size = (stack_size - (stack_dim - 1) * margin) / stack_dim
        for z in range(stack_dim[2]):

            # Transpose every layer.
            stack_dim[0], stack_dim[1] = stack_dim[1], stack_dim[0]
            box_size[0], box_size[1] = box_size[1], box_size[0]

            # IMPORTANT: Compute object points and store as a dictionary for the `goal`
            for y in range(stack_dim[1]):
                for x in range(stack_dim[0]):
                    position = list((x + 0.5, y + 0.5, z + 0.5) * box_size)
                    position[0] += x * margin - stack_size[0] / 2
                    position[1] += y * margin - stack_size[1] / 2
                    position[2] += z * margin + 0.03
                    pose = (position, (0, 0, 0, 1))
                    pose = utils.multiply(zone_pose, pose)

                    # IMPORTANT: REPLACE THE TEMPLATE URDF
                    urdf = self.fill_template(box_template, {'DIM': box_size})
                    box_id = env.add_object(urdf, pose)
                    object_ids.append(box_id)
                    self.color_random_brown(box_id)

        # Randomly select top box on pallet and save ground truth pose.
        targets = []
        self.steps = []
        boxes = object_ids[:] # make copy
        while boxes:
            _, height, object_mask = self.get_true_image(env)
            top = np.argwhere(height > (np.max(height) - 0.03))
            rpixel = top[int(np.floor(np.random.random() * len(top)))]  # y, x
            box_id = int(object_mask[rpixel[0], rpixel[1]])
            if box_id in boxes:
                position, rotation = p.getBasePositionAndOrientation(box_id)
                rposition = np.float32(position) + np.float32([0, -10, 0])
                p.resetBasePositionAndOrientation(box_id, rposition, rotation)
                self.steps.append(box_id)
                targets.append((position, rotation))
                boxes.remove(box_id)

        self.steps.reverse()  # Time-reversed depalletizing.
        self.add_goal(objs=object_ids, matches=np.eye(len(object_ids)), targ_poses=targets, replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
        self.spawn_box()

    def reward(self):
        reward, info = super().reward()
        self.spawn_box()
        return reward, info
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""place-red-in-green"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [place-red-in-green]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """"""pick up the red blocks and place them into the green bowls amidst other objects.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the red blocks in a green bowl""
        self.task_completed_desc = ""done placing blocks in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""stack-block-pyramid"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [stack-block-pyramid]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """"""Build a pyramid of colored blocks in a color sequence""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""make the {row} row with {blocks}""
        self.task_completed_desc = ""done stacking block pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks=""the green, blue and purple blocks"", row=""bottom"")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks=""the yellow and orange blocks"", row=""middle"")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks=""the red block"", row=""top"")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sweeping-piles"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sweeping-piles]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """"""Push piles of small objects into a target goal zone marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""push the pile of blocks into the green square""
        self.task_completed_desc = ""done sweeping.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""build-wheel"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [build-wheel]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildWheel(Task):
    """"""Construct a wheel using blocks and a sphere.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Construct a wheel using blocks and a sphere. First, position eight blocks in a circular layout on the tabletop. Each block should be touching its two neighbors and colored in alternating red and blue. Then place a green sphere in the center of the circular layout, completing the wheel.""
        self.task_completed_desc = ""done building wheel.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i % 2])
            blocks.append(block_id)

        # Add sphere.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_color = utils.COLORS['green']
        sphere_pose = ((0.5, 0.0, 0.0), (0,0,0,1)) # fixed pose
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=sphere_color)

        # Goal: blocks are arranged in a circle and sphere is in the center.
        circle_radius = 0.1
        circle_center = (0, 0, block_size[2] / 2)
        angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)
        block_poses = [(circle_center[0] + circle_radius * np.cos(angle),
                        circle_center[1] + circle_radius * np.sin(angle),
                        circle_center[2]) for angle in angles]
        block_poses = [(utils.apply(sphere_pose, pos), sphere_pose[1]) for pos in block_poses]
        self.add_goal(objs=blocks, matches=np.ones((8, 8)), targ_poses=block_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=8 / 9, language_goal=self.lang_template)

        # Goal: sphere is in the center of the blocks.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[sphere_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1 / 9, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""push-piles-into-letter"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [push-piles-into-letter]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildWheel(Task):
    """"""Construct a wheel using blocks and a sphere.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Construct a wheel using blocks and a sphere. First, position eight blocks in a circular layout on the tabletop. Each block should be touching its two neighbors and colored in alternating red and blue. Then place a green sphere in the center of the circular layout, completing the wheel.""
        self.task_completed_desc = ""done building wheel.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i % 2])
            blocks.append(block_id)

        # Add sphere.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_color = utils.COLORS['green']
        sphere_pose = ((0.5, 0.0, 0.0), (0,0,0,1)) # fixed pose
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=sphere_color)

        # Goal: blocks are arranged in a circle and sphere is in the center.
        circle_radius = 0.1
        circle_center = (0, 0, block_size[2] / 2)
        angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)
        block_poses = [(circle_center[0] + circle_radius * np.cos(angle),
                        circle_center[1] + circle_radius * np.sin(angle),
                        circle_center[2]) for angle in angles]
        block_poses = [(utils.apply(sphere_pose, pos), sphere_pose[1]) for pos in block_poses]
        self.add_goal(objs=blocks, matches=np.ones((8, 8)), targ_poses=block_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=8 / 9, language_goal=self.lang_template)

        # Goal: sphere is in the center of the blocks.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[sphere_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1 / 9, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""connect-boxes-with-rope"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [connect-boxes-with-rope]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import IPython

class ConnectBoxesWithRope(Task):
    """"""Connect two colored blocks with ropes.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""connect the {color1} and {color2} blocks with the rope.""
        self.task_completed_desc = ""done connecting.""
        self.additional_reset()
        self.pos_eps = 0.04 # higher tolerance

    def reset(self, env):
        super().reset(env)
        colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        blocks = []
        target_colors = np.random.choice(colors, 2, replace=False)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        corner_poses = []

        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)
            if color in target_colors:
                corner_poses.append(block_pose)

        dist = np.linalg.norm(np.array(corner_poses[0][0])-np.array(corner_poses[1][0])) 
        n_parts = int(20 * dist / 0.4)

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_poses[0][0], corner_poses[1][0]), n_parts=n_parts)
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1.,
                language_goal=self.lang_template.format(color1=target_colors[0], color2=target_colors[1]))

        # wait for the scene to settle down
        for i in range(600):
            p.stepSimulation()
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""build-car"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [build-car]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildCar(Task):
    """"""Construct a simple car structure using blocks and cylinders.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""Construct a simple car structure using blocks and cylinders. "" \
                             ""Firstly, create the base of the car by positioning two red blocks side by side. "" \
                             ""Then, add the car body by stacking a blue block on top of the base. "" \
                             ""For the wheels, place a black cylinder on each side of the base blocks.""
        self.task_completed_desc = ""done building car.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        car_pose = ((0.5, 0.0, 0.0), (0,0,0,1))  # fixed pose
        base_length = 0.04
        self.add_corner_anchor_for_pose(env, car_pose)

        # Add base blocks. Use box template so that we can change its size.
        base_size = (0.02, 0.04, 0.02)
        base_block_urdf = ""box/box-template.urdf""
        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(car_pose, (base_length / 2,  base_length / 2, 0.001)), car_pose[1]),
                        (utils.apply(car_pose, (-base_length / 2,  base_length / 2, 0.001)), car_pose[1])]
        base_blocks = []
        
        for idx in range(2):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['red'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.04, 0.02, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [car_pose]

        wheel_length = 0.12
        anchor_wheel_poses = [(utils.apply(car_pose, ( wheel_length / 2,  wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, (-wheel_length / 2,  wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, ( wheel_length / 2, -wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, (-wheel_length / 2, -wheel_length / 2, 0.001)), car_pose[1])]

        # Add wheels.
        wheel_size = (0.02, 0.02, 0.02)  # x, y, z dimensions for the asset size
        wheel_urdf = 'cylinder/cylinder-template.urdf'
        wheel_urdf = self.fill_template(wheel_urdf, {'DIM': wheel_size})

        wheels = []
        for idx in range(4):
            wheel_pose = self.get_random_pose(env, wheel_size)
            wheel_id = env.add_object(wheel_urdf, wheel_pose, color=utils.COLORS['black'])
            wheels.append(wheel_id)

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks,
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""Firstly, create the base of the car by positioning two red blocks side by side."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""Then, add the car body by stacking a blue block on top of the base."")

        # For the wheels, place a black cylinder on each side of the base blocks.
        self.add_goal(objs=wheels,
                      matches=np.ones((4, 4)),
                      targ_poses=anchor_wheel_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""For the wheels, place a black cylinder on each side of the base blocks."")


```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""manipulating-two-ropes"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [manipulating-two-ropes]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class ManipulatingTwoRopes(Task):
    """"""rearrange the red and blue deformable ropes such that it connects the two endpoints of a 3-sided square of corresponding color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""rearrange the {color_name} rope such that it connects the two endpoints of a 3-sided square of corresponding color.""
        self.task_completed_desc = ""done manipulating two ropes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square for the red rope.
        color_list = ['red', 'blue']
        for color_name in color_list:
            square_size = (length, length, 0)
            square_pose = self.get_random_pose(env, square_size)
            square_template = 'square/square-template.urdf'

            # IMPORTANT: REPLACE THE TEMPLATE URDF  with `fill_template`
            replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}
            urdf = self.fill_template(square_template, replace)
            env.add_object(urdf, square_pose, 'fixed', color=utils.COLORS[color_name])

            # compute corners
            corner0 = (length / 2, length / 2, 0.001)
            corner1 = (-length / 2, length / 2, 0.001)
            corner_0 = utils.apply(square_pose, corner0)
            corner_1 = utils.apply(square_pose, corner1)

            # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
            objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1), color_name=color_name)
            self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                    rotations=False, metric='pose', params=None, step_max_reward=1. / len(color_list),
                          language_goal=self.lang_template.format(color_name=color_name))

        print(f""len of languages: {len(self.lang_goals)} obj:{len(objects)}"")
        for i in range(480):
            p.stepSimulation()

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insert-sphere-into-container"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insert-sphere-into-container]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertSphereIntoContainer(Task):
    """"""Pick up a blue sphere and place it into an open container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""pick up a blue sphere and place it into an open container""
        self.task_completed_desc = ""done inserting sphere into container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        container_id = env.add_object(container_urdf, container_pose, 'fixed')

        # Add sphere.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_pose = self.get_random_pose(env, sphere_size)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS['blue'])

        # Goal: the blue sphere is in the container.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insert-cylinder-in-container"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insert-cylinder-in-container]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertSphereIntoContainer(Task):
    """"""Pick up a blue sphere and place it into an open container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""pick up a blue sphere and place it into an open container""
        self.task_completed_desc = ""done inserting sphere into container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        container_id = env.add_object(container_urdf, container_pose, 'fixed')

        # Add sphere.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_pose = self.get_random_pose(env, sphere_size)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS['blue'])

        # Goal: the blue sphere is in the container.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""build-bridge"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [build-bridge]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insert-ell-in-fixture"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insert-ell-in-fixture]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""build-block-tower-on-pallet"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [build-block-tower-on-pallet]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-tower"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-tower]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""stack-blocks-in-container"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [stack-blocks-in-container]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class StackBlocksInContainer(Task):
    """"""Pick up five blocks of different colors (red, blue, green, yellow, and orange) 
    and stack them in a container in a specific sequence. 
    The bottom of the stack should start with a red block followed by a blue, 
    green, yellow and finally an orange block at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""stack the blocks in the container in the following order: {order}""
        self.task_completed_desc = ""done stacking blocks in container.""
        self.order = ['red', 'blue', 'green', 'yellow', 'orange']
        self.colors = [utils.COLORS[color] for color in self.order]

    def reset(self, env):
        super().reset(env)

        # Add container.
        container_size = (0.15, 0.15, 0.15)  # x, y, z dimensions for the container size
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in self.colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Goal: each block is stacked in the container in the specified order.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                            language_goal=self.lang_template.format(order=', '.join(self.order)))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-block-tower"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-block-tower]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBlockTower(Task):
    """"""Stack four blocks on a pallet in the following order from bottom to top: 
    two blue blocks side by side, one red block centered on the blue blocks, 
    and one green block on top of the red block.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""stack four blocks on a pallet in the following order from bottom to top: two blue blocks side by side, one red block centered on the blue blocks, and one green block on top of the red block.""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.015)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['blue'], utils.COLORS['blue'], utils.COLORS['red'], utils.COLORS['green']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02), (0, 0, 0.06), (0, 0, 0.10)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: two blue blocks are placed side by side on the pallet.
        # Break the language prompt step-by-step
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                language_goal=""place two blue blocks side by side on the pallet"")

        # Goal: one red block is placed centered on the blue blocks.
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                language_goal=""place one red block centered on the blue blocks"")

        # Goal: one green block is placed on top of the red block.
        self.add_goal(objs=blocks[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                language_goal=""place one green block on top of the red block"")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-structured-block-tower"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-structured-block-tower]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorStructuredBlockTower(Task):
    """"""Construct a tower using six blocks: two red, two blue, and two green. 
    The tower should be built in the order of a red block at the base, 
    followed by a blue, then green, then red, blue and green at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""construct a tower using six blocks: two red, two blue, and two green. "" \
                             ""The tower should be built in the order of a red block at the base, "" \
                             ""followed by a blue, then green, then red, blue and green at the top.""
        self.task_completed_desc = ""done building color-structured block tower.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define block colors and sizes
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']] * 2
        block_size = (0.04, 0.04, 0.04)

        # Add blocks
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Define target poses for the blocks in the tower
        base_pose = self.get_random_pose(env, block_size)
        targ_poses = [base_pose]
        for i in range(1, 6):
            targ_poses.append((np.array(base_pose[0]) + np.array([0, 0, i * block_size[2]]), base_pose[1]))

        # Add goals
        for i in range(6):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/6, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""stack-color-coordinated-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [stack-color-coordinated-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class StackColorCoordinatedBlocks(Task):
    """"""Pick up six blocks of different colors (red, blue, green, yellow, orange, and purple) 
    and stack them on a pallet in two separate stacks. The first stack should be red at the bottom, 
    blue in the middle, and green at top. The second stack should be yellow at the bottom, 
    orange in the middle, and purple at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the blocks on the pallet in two separate stacks. "" \
                             ""The first stack should be red at the bottom, blue in the middle, "" \
                             ""and green at top. The second stack should be yellow at the bottom, "" \
                             ""orange in the middle, and purple at the top.""
        self.task_completed_desc = ""done stacking color-coordinated blocks.""

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['purple']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'box/box-template.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02), 
                     (0, -0.05, 0.06), (0, 0, 0.06), (0, 0.05, 0.06)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the pallet in two separate stacks.
        # First stack: red at the bottom, blue in the middle, and green at top.
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)

        # Second stack: yellow at the bottom, orange in the middle, and purple at the top.
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""assemble-single-car"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [assemble-single-car]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class AssembleSingleCar(Task):
    """"""Assemble a mini car using a large blue box as the body, a smaller red box on top as the roof, and two tiny green boxes on the sides as wheels.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""build a mini car using a large blue box as the body, a smaller red box on top as the roof, and two tiny green boxes on the sides as wheels""
        self.task_completed_desc = ""done assembling the car.""

    def reset(self, env):
        super().reset(env)

        # Add car body (large blue box).
        body_size = (0.1, 0.05, 0.02)  # x, y, z dimensions
        body_pose = self.get_random_pose(env, body_size)
        body_urdf = 'box/box-template.urdf'
        body_color = utils.COLORS['blue']
        body_id = env.add_object(body_urdf, body_pose, color=body_color)

        # Add car roof (smaller red box).
        roof_size = (0.08, 0.04, 0.02)  # x, y, z dimensions
        roof_pose = self.get_random_pose(env, roof_size)
        roof_urdf = 'box/box-template.urdf'
        roof_color = utils.COLORS['red']
        roof_id = env.add_object(roof_urdf, roof_pose, color=roof_color)

        # Add car wheels (two tiny green boxes).
        wheel_size = (0.02, 0.02, 0.01)  # x, y, z dimensions
        wheel_urdf = 'box/box-template.urdf'
        wheel_color = utils.COLORS['green']
        wheel_ids = []
        
        for _ in range(2):
            wheel_pose = self.get_random_pose(env, wheel_size)
            wheel_id = env.add_object(wheel_urdf, wheel_pose, color=wheel_color)
            wheel_ids.append(wheel_id)

        # Goal: assemble the car by placing the roof on the body and the wheels on the sides.
        # The target poses are calculated based on the body pose.
        roof_targ_pose = (body_pose[0] + np.array([0, 0, body_size[2] + roof_size[2]/2]), body_pose[1])
        wheel_targ_poses = [(body_pose[0] + np.array([0, body_size[1]/2 + wheel_size[1]/2, -body_size[2]/2]), body_pose[1]),
                            (body_pose[0] + np.array([0, -body_size[1]/2 - wheel_size[1]/2, -body_size[2]/2]), body_pose[1])]

        # Add the goals.
        self.add_goal(objs=[roof_id], matches=np.ones((1, 1)), targ_poses=[roof_targ_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/3, language_goal=self.lang_template)

        self.add_goal(objs=wheel_ids, matches=np.ones((2, 2)), targ_poses=wheel_targ_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=2/3, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sort-and-stack-clr-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sort-and-stack-clr-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortAndStackClrBlocks(Task):
    """"""Pick up four blocks of different colors (red, blue, green, yellow) and place them into separate corners of a pallet. After sorting, stack them in a specific sequence on top of the pallet. The bottom of the stack should start with a green block followed by a blue, then red, and finally a yellow block at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""sort and stack the blocks in the order of green, blue, red, and yellow""
        self.task_completed_desc = ""done sorting and stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0.05, 0.05, 0.02), (-0.05, 0.05, 0.02), (-0.05, -0.05, 0.02), (0.05, -0.05, 0.02)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are sorted into separate corners of the pallet.
        self.add_goal(objs=blocks, matches=np.eye(4), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=0.5, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)

        # Associate stacking locations for goals.
        stack_pos = [(0, 0, 0.02), (0, 0, 0.06), (0, 0, 0.10), (0, 0, 0.14)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in stack_pos]

        # Goal: blocks are stacked on top of the pallet in the order of green, blue, red, and yellow.
        self.add_goal(objs=blocks, matches=np.eye(4), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=0.5, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""create-pyramid-blocks-and-container"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [create-pyramid-blocks-and-container]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CreatePyramidBlocksAndContainer(Task):
    """"""Create a pyramid structure using six blocks of three different colors (two red, two green, and two blue) inside a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Create a pyramid structure using six blocks of three different colors (two red, two green, and two blue) inside a container.""
        self.task_completed_desc = ""done creating pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.3, 0.3, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')
        self.add_corner_anchor_for_pose(env, container_pose)


        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['blue']]
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03), (0, 0.05, 0.03), (0, -0.025, 0.08), (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(container_pose, i), container_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, green, blue).
        self.add_goal(objs=blocks[2:5], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the green and blue blocks"",
                                                         row=""bottom""))

        # Goal: blocks are stacked in a pyramid (middle row: red, red).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template.format(blocks=""the red blocks"",
                                                         row=""middle""))

        # Goal: blocks are stacked in a pyramid (top row: blue).
        self.add_goal(objs=blocks[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(blocks=""the blue block"",
                                                         row=""top""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""Four-corner-pyramid-challenge"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [Four-corner-pyramid-challenge]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class FourCornerPyramidChallenge(Task):
    """"""Construct a pyramid of blocks in each zone with a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a pyramid of blocks in each zone with the sequence red, blue, green, and yellow from bottom to top""
        self.task_completed_desc = ""done building pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            for _ in range(4):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=colors[i])
                blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_pose, i), zone_pose[1]) for i in place_pos for zone_pose in zone_poses]

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(4):
            self.add_goal(objs=blocks[i*4:(i+1)*4], matches=np.ones((4, 4)), targ_poses=targs[i*4:(i+1)*4], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""colorful-block-tower-on-cylinder-base"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [colorful-block-tower-on-cylinder-base]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorfulBlockTowerOnCylinderBase(Task):
    """"""Construct a tower using four blocks of different colors (red, blue, green, and yellow) on a placed cylindrical base at the corner of the tabletop. The sequence from bottom to top should be red, blue, green, and yellow.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""construct a tower using four blocks of different colors (red, blue, green, and yellow) on a placed cylindrical base at the corner of the tabletop. The sequence from bottom to top should be red, blue, green, and yellow.""
        self.task_completed_desc = ""done building the tower.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylindrical base.
        # x, y, z dimensions for the asset size
        base_size = (0.05, 0.05, 0.05)
        base_urdf = 'cylinder/cylinder-template.urdf'
        base_pose = self.get_random_pose(env, base_size)
        base_id = env.add_object(base_urdf, base_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'

        objs = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, 0, 0.05), (0, 0, 0.09), (0, 0, 0.13), (0, 0, 0.17)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the cylindrical base in the order red, blue, green, yellow from bottom to top.
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""construct-corner-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [construct-corner-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ConstructCornerBlocks(Task):
    """"""Create a corner structure using four blocks. Two red blocks form the base, one on each side of the corner, followed by a green block that is positioned on the red blocks at the corner junction, and finally a blue block on top of the green one. The overall structure forms a 3-D corner.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Create a corner structure using four blocks. Two red blocks form the base, one on each side of the corner, followed by a green block that is positioned on the red blocks at the corner junction, and finally a blue block on top of the green one. The overall structure forms a 3-D corner.""
        self.task_completed_desc = ""done constructing corner blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corner.
        corner_size = (0.15, 0.15, 0.05)
        corner_urdf = 'corner/corner-template.urdf'
        corner_pose = self.get_random_pose(env, corner_size)
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02), (0, 0, 0.06), (0, 0, 0.10)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a corner (bottom row: two red blocks).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a corner (middle row: one green block).
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*1,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a corner (top row: one blue block).
        self.add_goal(objs=blocks[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*1,
                          language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""corner-sort-cylinders"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [corner-sort-cylinders]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CornerSortCylinders(Task):
    """"""Pick up cylinders of four different colors (red, blue, green, yellow) and place them into four corners accordingly marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} cylinder in the {color} corner""
        self.task_completed_desc = ""done sorting cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors
        colors = ['red', 'blue', 'green', 'yellow']

        # Add corners
        corner_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the asset size
        corner_template = 'corner/corner-template.urdf'
        corner_poses = []
        for color in colors:
            replace = {'DIM': corner_size, 'HALF': (corner_size[0] / 2, corner_size[1] / 2, corner_size[2] / 2), 'COLOR': utils.COLORS[color]}
            corner_urdf = self.fill_template(corner_template, replace)
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, 'fixed')
            corner_poses.append(corner_pose)

        # Add cylinders
        cylinder_size = (0.02, 0.02, 0.06)  # x, y, z dimensions for the asset size
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in colors:
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2), 'COLOR': utils.COLORS[color]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Add goals
        for i in range(len(cylinders)):
            self.add_goal(objs=[cylinders[i]], matches=np.int32([[1]]), targ_poses=[corner_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(cylinders),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sorting-blocks-into-pallets"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sorting-blocks-into-pallets]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortingBlocksIntoPallets(Task):
    """"""Pick up blocks of four different colors (red, blue, green, yellow) and place them into four separate pallets of matching color. The pallets are placed in a row and the blocks are scattered randomly on the table.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} block into the {color} pallet""
        self.task_completed_desc = ""done sorting blocks into pallets.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.12, 0.12, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        pallet_colors = ['red', 'blue', 'green', 'yellow']
        for color in pallet_colors:
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, 'fixed', color=utils.COLORS[color])
            pallet_poses.append(pallet_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        for color in pallet_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in a different pallet of matching color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[pallet_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), 
                language_goal=self.lang_template.format(color=pallet_colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sort-and-assemble-block-castle"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sort-and-assemble-block-castle]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortAndAssembleBlockCastle(Task):
    """"""Sort blocks by color and assemble them into a castle-like structure.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 50
        self.lang_template = ""sort the blocks by color and assemble them into a castle""
        self.task_completed_desc = ""done sorting and assembling.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]
        blocks = []
        for color in block_colors:
            for _ in range(4):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=color)
                blocks.append(block_id)

        # Goal: each block is in a different zone based on color.
        for i in range(12):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 3)), targ_poses=zone_poses, replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/12)

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(3):
            zone_blocks = blocks[i*4:(i+1)*4]
            place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02),
                         (0, 0, 0.06), (0, 0, 0.10)]
            targs = [(utils.apply(zone_poses[i], pos), zone_poses[i][1]) for pos in place_pos]
            for j in range(4):
                self.add_goal(objs=[zone_blocks[j]], matches=np.ones((1, 1)), targ_poses=[targs[j]], replace=False,
                              rotations=True, metric='pose', params=None, step_max_reward=1/12, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""vertical-insertion-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [vertical-insertion-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class VerticalInsertionBlocks(Task):
    """"""Pick up four color specific blocks and insert each block into four differently colored stands set upright on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} stand""
        self.task_completed_desc = ""done inserting blocks into stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and stands
        colors = ['red', 'blue', 'green', 'yellow']

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.04, 0.04, 0.1)
        stand_urdf = 'stacking/stand.urdf'
        stands = []
        for color in colors:
            stand_pose = self.get_random_pose(env, stand_size)
            stand_id = env.add_object(stand_urdf, stand_pose, color=utils.COLORS[color], category='fixed')
            stands.append(stand_id)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is inserted into the stand of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(stands[i])], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-sphere-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-sphere-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedSphereInsertion(Task):
    """"""Insert each sphere into the bowl of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert each sphere into the bowl of the same color""
        self.task_completed_desc = ""done inserting spheres into bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = ['red', 'blue', 'green', 'yellow']
        color_values = [utils.COLORS[color] for color in colors]

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0.02)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for i in range(4):
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed', color=color_values[i])
            bowl_poses.append(bowl_pose)

        # Add spheres.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_template = 'sphere/sphere-template.urdf'
        spheres = []
        for i in range(4):
            sphere_pose = self.get_random_pose(env, sphere_size)
            replace = {'DIM': sphere_size, 'HALF': (sphere_size[0] / 2, sphere_size[1] / 2, sphere_size[2] / 2)}
            sphere_urdf = self.fill_template(sphere_template, replace)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=color_values[i])
            spheres.append(sphere_id)

        # Goal: each sphere is in a bowl of the same color.
        for i in range(4):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[bowl_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=f""insert the {colors[i]} sphere into the {colors[i]} bowl"")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""block-pyramid-with-limited-space"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [block-pyramid-with-limited-space]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BlockPyramidWithLimitedSpace(Task):
    """"""Sort blocks according to color into three zones on the tabletop and construct a pyramid in each zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 50
        self.lang_template = ""sort the blocks according to color into three zones and construct a pyramid in each zone""
        self.task_completed_desc = ""done sorting and constructing pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=color)
                blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_pose, i), zone_pose[1]) for zone_pose in zone_poses for i in place_pos]

        # Goal: blocks are sorted and stacked in a pyramid in each zone.
        for i in range(3):
            self.add_goal(objs=blocks[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                    language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""build-cylinder-structure"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [build-cylinder-structure]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildCylinderStructure(Task):
    """"""Construct a structure using four colored cylinders (red, blue, green, yellow) on a square base.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 5
        self.lang_template = ""construct a structure using four colored cylinders on a square base""
        self.task_completed_desc = ""done building the cylinder structure.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add square base.
        # x, y, z dimensions for the asset size
        base_size = (0.15, 0.15, 0.005)
        base_urdf = 'square/square-template.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Cylinder colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']
        ]

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.08)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        objs = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            objs.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.04), (0, 0.05, 0.04),
                     (0, 0.05, 0.12), (0, -0.05, 0.12)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: red and blue cylinders are placed side by side on the base.
        self.add_goal(objs=objs[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                language_goal=""place the red and blue cylinders side by side on the base"")

        # Goal: green cylinder is placed on top of the blue cylinder.
        self.add_goal(objs=[objs[2]], matches=np.ones((1, 1)), targ_poses=[targs[2]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                language_goal=""place the green cylinder on top of the blue cylinder"")

        # Goal: yellow cylinder is placed on top of the red cylinder.
        self.add_goal(objs=[objs[3]], matches=np.ones((1, 1)), targ_poses=[targs[3]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                language_goal=""place the yellow cylinder on top of the red cylinder"")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insert-blocks-lineup"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insert-blocks-lineup]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertBlocksLineup(Task):
    """"""Pick up four different color blocks and insert them into the corresponding color fixtures.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and fixtures
        colors = ['red', 'blue', 'green', 'yellow']

        # Add fixtures.
        fixture_size = (0.04, 0.04, 0.04)
        fixture_urdf = 'insertion/fixture.urdf'
        fixture_poses = []
        for i in range(4):
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[colors[i]], category='fixed')
            fixture_poses.append((fixture_pose, fixture_id))

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[colors[i]])
            blocks.append(block_id)

        # Add small blocks as barriers.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'block/small.urdf'
        for _ in range(10):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is in the corresponding color fixture.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[fixture_poses[i][0]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-specific-container-fill"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-specific-container-fill]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSpecificContainerFill(Task):
    """"""Arrange four colored blocks (red, blue, green, and yellow) around a pallet. 
    Then, pick up these blocks and place them inside a container marked in the same color. 
    The task requires precise placement, color matching, and an understanding of spatial structures.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} block in the {color} container""
        self.task_completed_desc = ""done arranging blocks in containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define block and container colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add blocks and containers.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        container_size = (0.12, 0.12, 0.05)
        container_template = 'container/container-template.urdf'
        blocks = []
        containers = []
        for color in colors:
            # Add block.
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

            # Add container.
            container_pose = self.get_random_pose(env, container_size)
            replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
            container_urdf = self.fill_template(container_template, replace)
            container_id = env.add_object(container_urdf, container_pose, 'fixed', color=utils.COLORS[color])
            containers.append(container_id)

        # Goal: each block is in a container of the same color.
        for i in range(len(colors)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(containers[i])], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""multicolor-block-bridge"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [multicolor-block-bridge]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MulticolorBlockBridge(Task):
    """"""Build a bridge by stacking three red, three blue, and three green blocks on a pallet. 
    Arrange in a sequence from left to right: red, blue, and green. 
    Then, place three cylinders of corresponding colors on top of the stacked blocks, forming a bridge. 
    The cylinders should roll from the top block to the pallet, creating a challenge of precision and control.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Build a bridge by stacking three red, three blue, and three green blocks on a pallet. Arrange in a sequence from left to right: red, blue, and green. Then, place three cylinders of corresponding colors on top of the stacked blocks, forming a bridge.""
        self.task_completed_desc = ""done building the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']]
        blocks = []
        for i in range(9):  # 3 blocks of each color
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i // 3])
            blocks.append(block_id)

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(3):  # 1 cylinder of each color
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2)}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=block_colors[i])
            cylinders.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03), (0, 0.05, 0.03)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the pallet in the order red, blue, green.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i // 3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 9, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: cylinders are placed on top of the stacked blocks.
        for i in range(3):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2], 
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""pyramid-blocks-assemble"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [pyramid-blocks-assemble]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PyramidBlocksAssemble(Task):
    """"""Construct a pyramid using nine blocks in a specific color order on a pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""construct a pyramid using nine blocks in a specific color order on a pallet""
        self.task_completed_desc = ""done constructing pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.35, 0.35, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for _ in range(9):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [
            (-0.1, -0.1, 0.02), (0, -0.1, 0.02), (0.1, -0.1, 0.02), (-0.1, 0, 0.02), (0.1, 0, 0.02),
            (-0.05, 0.05, 0.06), (0.05, 0.05, 0.06), (0, 0.1, 0.06),
            (0, 0.05, 0.1)
        ]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid in a specific color order.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 9, 
                          language_goal=self.lang_template.format(blocks=""the blocks"",
                                                             row=""row""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""place-ball-in-elevated-bowl"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [place-ball-in-elevated-bowl]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class PlaceBallInElevatedBowl(Task):
    """"""Pick up a red ball and carefully place it into a bowl, which is positioned on a raised platform that is surrounded by small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the red ball in the elevated bowl""
        self.task_completed_desc = ""done placing ball in bowl.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add elevated platform.
        platform_size = (0.3, 0.3, 0.05)

        # Add bowl on the platform.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_pose[0][2] += platform_size[2]  # place the bowl on top of the platform
        bowl_id = env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Add red ball.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        ball_pose = self.get_random_pose(env, ball_size)
        ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS['red'])

        # Add small blocks around the platform.
        block_size = (0.02, 0.02, 0.02)
        block_urdf = 'block/small.urdf'
        for _ in range(5):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: the red ball is in the bowl.
        self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[bowl_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-balls-in-colored-zones"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-balls-in-colored-zones]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class AlignBallsInColoredZones(Task):
    """"""Align balls of different colors in correspondingly colored zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} zone""
        self.task_completed_desc = ""done aligning balls in colored zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for balls and zones
        colors = ['red', 'blue', 'green', 'yellow', 'orange', 'purple']
        color_names = ['Red', 'Blue', 'Green', 'Yellow', 'Orange', 'Purple']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(6):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for i in range(6):
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'DIM': ball_size, 'HALF': (ball_size[0] / 2, ball_size[1] / 2, ball_size[2] / 2), 'COLOR': colors[i]}
            ball_urdf = self.fill_template(ball_urdf, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            balls.append(ball_id)

        # Goal: each ball is in a different colored zone.
        for i in range(6):
            self.add_goal(objs=[balls[i]], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6,
                language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-cylinder-tower"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-cylinder-tower]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedCylinderTower(Task):
    """"""Stack cylinders of four different colors (red, blue, green, yellow) on top of each other on a square stand in a specific sequence. The bottom of the stack should start with a blue cylinder, follow by a green cylinder, then a red one, and finally a yellow cylinder at the top. Each cylinder has to be aligned correctly to avoid falling.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Stack cylinders of four different colors (red, blue, green, yellow) on top of each other on a square stand in a specific sequence. The bottom of the stack should start with a blue cylinder, follow by a green cylinder, then a red one, and finally a yellow cylinder at the top.""
        self.task_completed_desc = ""done stacking cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Cylinder colors.
        colors = [utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['red'], utils.COLORS['yellow']]

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        objs = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            objs.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, 0, 0.03), (0, 0, 0.08), (0, 0, 0.13), (0, 0, 0.18)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: cylinders are stacked in a tower (bottom to top: blue, green, red, yellow).
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""symmetric-block-bridge-construction"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [symmetric-block-bridge-construction]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SymmetricBlockBridgeConstruction(Task):
    """"""Create a symmetrical bridge-shaped structure on a stand using eight blocks of two different colors (four red and four blue).""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""create a symmetrical bridge-shaped structure on a stand using eight blocks of two different colors (four red and four blue)""
        self.task_completed_desc = ""done building the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i%2])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13),
                     (0, -0.025, 0.18), (0, 0.025, 0.18)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a bridge (bottom row: red, red).
        self.add_goal(objs=objs[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (second row: blue).
        self.add_goal(objs=objs[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (third row: red).
        self.add_goal(objs=objs[3:4], matches=np.ones((1, 1)), targ_poses=targs[3:4], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (fourth row: blue).
        self.add_goal(objs=objs[4:5], matches=np.ones((1, 1)), targ_poses=targs[4:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (fifth row: red).
        self.add_goal(objs=objs[5:6], matches=np.ones((1, 1)), targ_poses=targs[5:6], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (sixth row: blue).
        self.add_goal(objs=objs[6:7], matches=np.ones((1, 1)), targ_poses=targs[6:7], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (top row: red, red).
        self.add_goal(objs=objs[7:], matches=np.ones((1, 1)), targ_poses=targs[7:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sphere-align-stand"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sphere-align-stand]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SphereAlignStand(Task):
    """"""Pick up each sphere and place it on the stand of the matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 5
        self.lang_template = ""place the {color} sphere on the {color} stand""
        self.task_completed_desc = ""done aligning spheres with stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the spheres and stands
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = ['red', 'green', 'blue', 'yellow', 'purple']

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.05, 0.05, 0.05)
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i in range(5):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, 'fixed', color=utils.COLORS[colors[i]])
            stand_poses.append(stand_pose)

        # Add spheres.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for i in range(5):
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[colors[i]])
            spheres.append(sphere_id)

        # Goal: each sphere is on the stand of the matching color.
        for i in range(5):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[stand_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""construct-colorful-arch"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [construct-colorful-arch]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ConstructColorfulArch(Task):
    """"""Construct an arch using six blocks: three red, and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Construct an arch using six blocks: three red, and three blue.""
        self.task_completed_desc = ""done constructing colorful arch.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            color = colors[i // 3]  # First three blocks are red, last three are blue
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02),  # Base layer
                     (0, 0, 0.06),  # Second layer
                     (0, -0.05, 0.10), (0, 0.05, 0.10),  # Third layer
                     (0, 0, 0.14)]  # Top layer
        targs = [(utils.apply(block_pose, i), block_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in an arch (bottom layer: red, red).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=""Place two red blocks on the tabletop parallel to each other"")

        # Goal: blocks are stacked in an arch (second layer: blue).
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=""Place a blue block on top of the red blocks to form a basic arch"")

        # Goal: blocks are stacked in an arch (third layer: red, red).
        self.add_goal(objs=blocks[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=""Place a red block on each side of the base arch"")

        # Goal: blocks are stacked in an arch (top layer: blue).
        self.add_goal(objs=blocks[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=""Bridge them with the last blue block"")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-sorted-container-stack"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-sorted-container-stack]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSortedContainerStack(Task):
    """"""Stack four differently colored blocks (red, blue, green, yellow) inside a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the blocks in the container in the order: red, blue, green, then yellow""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.15, 0.15, 0.15)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        for i in range(2):
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Goal: each block is stacked in the container in the order: red, blue, green, yellow.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4,
                language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-spheres-in-colored-zones"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-spheres-in-colored-zones]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignSpheresInColoredZones(Task):
    """"""Align spheres of different colors in the matching colored zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere in the {color} zone""
        self.task_completed_desc = ""done aligning spheres in colored zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors
        colors = ['red', 'blue', 'green', 'yellow']
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for color in colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add spheres.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere-template.urdf'
        spheres = []
        for i, color in enumerate(colors):
            sphere_pose = self.get_random_pose(env, sphere_size)
            replace = {'DIM': sphere_size, 'HALF': (sphere_size[0] / 2, sphere_size[1] / 2, sphere_size[2] / 2)}
            sphere_urdf = self.fill_template(sphere_urdf, replace)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[color])
            spheres.append(sphere_id)

            # Add goal
            self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sort-insert-color-coordinated-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sort-insert-color-coordinated-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortInsertColorCoordinatedBlocks(Task):
    """"""Sort blocks by their colors and place them into the containers of the matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""sort the blocks by their colors and place them into the containers of the matching color""
        self.task_completed_desc = ""done sorting and inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        container_colors = ['red', 'blue', 'green']
        container_poses = []
        for color in container_colors:
            container_pose = self.get_random_pose(env, container_size)
            env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            container_poses.append(container_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = ['red', 'red', 'blue', 'blue', 'green', 'green']
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in a container of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_poses[i//2]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-ordered-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-ordered-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedInsertion(Task):
    """"""Insert differently-colored ell objects into the matching color fixture in a specific order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} ell into the matching fixture""
        self.task_completed_desc = ""done inserting ells.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']
        color_order = {color: i for i, color in enumerate(colors)}

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0.02)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add ell objects.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell is inserted into the matching color fixture in the correct order.
        for i, ell in enumerate(ells):
            self.add_goal(objs=[ell], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(ells),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedInsertion(Task):
    """"""Insert each block into the fixture of the same color""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert each block into the fixture of the same color""
        self.task_completed_desc = ""done with color-coordinated-insertion.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.35, 0.35, 0.01)
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add fixtures and blocks.
        colors = ['red', 'blue', 'green', 'yellow']
        fixtures = []
        blocks = []
        fixture_size = (0.05, 0.05, 0.05)
        block_size = (0.04, 0.04, 0.04)
        fixture_urdf = 'insertion/fixture.urdf'
        block_urdf = 'block/block.urdf'
        for color in colors:
            # Add fixture.
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

            # Add block.
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                          language_goal=self.lang_template)

        # Goal: each fixture is on the pallet.
        for i in range(len(fixtures)):
            self.add_goal(objs=[fixtures[i]], matches=np.ones((1, 1)), targ_poses=[pallet_pose], replace=False,
                          rotations=True, metric='zone', params=[(pallet_pose, pallet_size)], step_max_reward=1 / len(fixtures),
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""cylinder-stand-alignment"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [cylinder-stand-alignment]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderStandAlignment(Task):
    """"""Arrange four colored cylinders (red, blue, green, yellow) in order of their colors on four stands of matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Arrange the {color} cylinder on the {color} stand""
        self.task_completed_desc = ""done arranging cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2),
                       'COLOR': colors[i]}
            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(cylinder_urdf, replace)
            cylinder_id = env.add_object(urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stands = []
        for i in range(4):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, color=colors[i], category='fixed')
            stands.append(stand_pose)

        # Goal: each cylinder is on a stand of the same color.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[stands[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 4,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-sorted-block-race"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-sorted-block-race]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSortedBlockRace(Task):
    """"""Pick up blocks of two colors and place them in corresponding colored zones in a sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the blocks in the corresponding colored zones in sequence""
        self.task_completed_desc = ""done placing blocks in zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_colors = ['blue', 'red']
        zone_poses = []
        for color in zone_colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = ['blue', 'red']
        blocks = []
        for color in block_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Goal: each block is in the corresponding colored zone.
        for i, block in enumerate(blocks):
            self.add_goal(objs=[block], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""multi-level-block-construction"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [multi-level-block-construction]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MultiLevelBlockConstruction(Task):
    """"""Construct a two-level structure on a pallet using four blocks: two red and two blue. 
    The lower level should be a rectangle created by placing the red blocks side by side. 
    The upper level is made up by placing the blue blocks placed on top of the red blocks 
    creating a line aligned perpendicular to the red blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""construct a two-level structure on a pallet using four blocks: two red and two blue""
        self.task_completed_desc = ""done constructing multi-level block structure.""

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.015)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['blue']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02),
                     (0, -0.02, 0.06), (0, 0.02, 0.06)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: red blocks are placed side by side on the pallet.
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2, language_goal=self.lang_template)

        # Goal: blue blocks are stacked on top of the red blocks.
        self.add_goal(objs=blocks[2:], matches=np.ones((2, 2)), targ_poses=targs[2:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-blocks-in-cylinder-maze"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-blocks-in-cylinder-maze]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorBlocksInCylinderMaze(Task):
    """"""Pick up five differently colored blocks (red, blue, yellow, green, and orange) that are scattered randomly on the table top. Arrange three cylindrical containers in a row to create a maze-like structure. Place the red, yellow, and blue block into the first, second, and third cylinder from left respectively. Then, stack the green and orange block on top of any container, followed by placing the same color palette on the respective block.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""arrange the blocks in the cylinders and stack the green and orange blocks""
        self.task_completed_desc = ""done arranging blocks in cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylinders.
        cylinder_size = (0.05, 0.05, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for _ in range(3):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            env.add_object(cylinder_urdf, cylinder_pose, 'fixed')
            cylinder_poses.append(cylinder_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['yellow'], utils.COLORS['green'], utils.COLORS['orange']]
        blocks = []
        for i in range(5):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Goal: red, yellow, and blue blocks are in the first, second, and third cylinder respectively.
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=cylinder_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=self.lang_template)

        # Goal: green and orange blocks are stacked on top of any cylinder.
        self.add_goal(objs=blocks[3:], matches=np.ones((2, 3)), targ_poses=cylinder_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""create-pyramid-with-color-coded-ells"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [create-pyramid-with-color-coded-ells]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class CreatePyramidWithColorCodedElls(Task):
    """"""Pick up ell-shaped objects of different colors and stack them onto a pallet in the shape of a pyramid.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the {color} ell on the pyramid""
        self.task_completed_desc = ""done stacking ell pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Ell colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], 
            utils.COLORS['yellow'], utils.COLORS['green']
        ]
        color_names = ['red', 'blue', 'yellow', 'green']

        # Add Ells.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        objs = []
        for i in range(4):
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=colors[i])
            objs.append(ell_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0, 0.08)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: Ells are stacked in a pyramid (bottom row: red, middle row: blue, top row: yellow, green).
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""move-piles-along-line"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [move-piles-along-line]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class MovePilesAlongLine(Task):
    """"""Move three piles of small blocks, each pile a different color (red, blue, green), 
    along three matching colored lines to three separate zones of the same color using a spatula.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the piles of blocks along the lines to the matching colored zones""
        self.task_completed_desc = ""done moving piles.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add three colored lines.
        line_template = 'line/line-template.urdf'
        line_colors = ['red', 'blue', 'green']
        line_poses = []
        for color in line_colors:
            line_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            line_pose = self.get_random_pose(env, line_size)
            replace = {'DIM': line_size, 'HALF': (line_size[0] / 2, line_size[1] / 2, line_size[2] / 2), 'COLOR': color}
            line_urdf = self.fill_template(line_template, replace)
            env.add_object(line_urdf, line_pose, 'fixed')
            line_poses.append(line_pose)

        # Add three colored zones.
        zone_template = 'zone/zone.urdf'
        zone_poses = []
        for color in line_colors:
            zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            zone_pose = self.get_random_pose(env, zone_size)
            replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2), 'COLOR': color}
            zone_urdf = self.fill_template(zone_template, replace)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add three piles of small blocks.
        block_template = 'block/small.urdf'
        block_colors = ['red', 'blue', 'green']
        block_ids = []
        for color in block_colors:
            block_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            block_pose = self.get_random_pose(env, block_size)
            replace = {'DIM': block_size, 'HALF': (block_size[0] / 2, block_size[1] / 2, block_size[2] / 2), 'COLOR': color}
            block_urdf = self.fill_template(block_template, replace)
            block_id = env.add_object(block_urdf, block_pose)
            block_ids.append(block_id)

        # Add goals.
        for i in range(3):
            self.add_goal(objs=[block_ids[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1/3,
                          language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-ordered-blocks-on-pallet"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-ordered-blocks-on-pallet]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedBlocksOnPallet(Task):
    """"""Pick up each colored block and place it onto the pallet in specific color sequence: red, blue, green, yellow, orange, and finally purple.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the colored blocks onto the pallet in the following order: red, blue, green, yellow, orange, and purple""
        self.task_completed_desc = ""done placing blocks on the pallet.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['purple']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are placed on the pallet in the order of red, blue, green, yellow, orange, purple.
        for i in range(6):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2], language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-ordered-container-arrangement"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-ordered-container-arrangement]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedContainerArrangement(Task):
    """"""Arrange six containers with blocks of matching colors in a specific color order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""arrange the containers in the color order: red, blue, green, yellow, orange, and purple""
        self.task_completed_desc = ""done arranging containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define color order
        color_order = ['red', 'blue', 'green', 'yellow', 'orange', 'purple']

        # Add containers and blocks
        container_template = 'container/container-template.urdf'
        container_size = (0.12, 0.12, 0.02)
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)

        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        containers = []
        blocks = []
        for color in color_order:
            # Add container
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            containers.append(container_id)

            # Add block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

            # Add subgoal to place block in container
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/6,
                          language_goal=self.lang_template)

        # Add final goal to arrange containers in color order
        container_poses = [self.get_random_pose(env, container_size) for _ in color_order]
        self.add_goal(objs=containers, matches=np.eye(len(color_order)), targ_poses=container_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""multi-level-pyramid-construction"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [multi-level-pyramid-construction]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MultiLevelPyramidConstruction(Task):
    """"""Construct a two-level pyramid on a pallet using six blocks: three green and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Construct a two-level pyramid on a pallet using six blocks: three green and three blue. The first level should be a triangle created by placing the green blocks side by side. The second level should be built by placing the blue blocks on top of the green blocks, forming another triangle rotated 60 degrees with respect to the first one.""
        self.task_completed_desc = ""done constructing pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.35, 0.35, 0.01)  # x, y, z dimensions for the pallet size
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['green']] * 3 + [utils.COLORS['blue']] * 3  # three green and three blue blocks

        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02),  # first level
                     (0, -0.025, 0.06), (0, 0.025, 0.06), (0, 0, 0.10)]  # second level
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (first level: green blocks).
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the green blocks"", row=""bottom""))

        # Goal: blocks are stacked in a pyramid (second level: blue blocks).
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the blue blocks"", row=""top""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-balls-in-colored-boxes"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-balls-in-colored-boxes]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignBallsInColoredBoxes(Task):
    """"""Align balls in colored boxes according to the color and sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} box""
        self.task_completed_desc = ""done aligning balls in boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add boxes.
        box_size = (0.12, 0.12, 0.12)
        box_urdf = 'box/box-template.urdf'
        box_poses = []
        boxes = []
        for i in range(4):
            box_pose = self.get_random_pose(env, box_size)
            box_id = env.add_object(box_urdf, box_pose, color=utils.COLORS[colors[i]])
            boxes.append(box_id)
            box_poses.append(box_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball.urdf'
        balls = []
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the box of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[box_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/4, 
                language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""colored-balls-sorting-in-corner"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [colored-balls-sorting-in-corner]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColoredBallsSortingInCorner(Task):
    """"""Pick up each ball and place it in the corner of the same color, in the specific sequence of red, blue, green and yellow, starting from the leftmost corner to the rightmost.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} corner""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add corners.
        corner_size = (0.12, 0.12, 0)
        corner_urdf = 'corner/corner-template.urdf'
        corner_poses = []
        for i in range(4):
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, 'fixed', color=utils.COLORS[colors[i]])
            corner_poses.append(corner_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the corner of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[corner_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-ball-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-ball-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBallInsertion(Task):
    """"""Insert balls into the cylinders of the same color in the order of red, blue, green, and yellow.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""insert the {color} ball into the {color} cylinder""
        self.task_completed_desc = ""done inserting balls into cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.05, 0.05, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            env.add_object(cylinder_urdf, cylinder_pose, category='fixed', color=utils.COLORS[colors[i]])
            cylinder_poses.append(cylinder_pose)

        # Add balls.
        # x, y, z dimensions for the asset size
        balls = []
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the corresponding color cylinder.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-sequenced-pyramid-packing"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-sequenced-pyramid-packing]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorSequencedPyramidPacking(Task):
    """"""Sort cubes by color into four pallets and stack them in each pallet as a pyramid""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""sort the {color} cubes into the pallet and stack them as a pyramid""
        self.task_completed_desc = ""done sorting and stacking cubes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        for _ in range(4):
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed')
            pallet_poses.append(pallet_pose)

        # Cube colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['yellow']
        ]

        # Add cubes.
        # x, y, z dimensions for the asset size
        cube_size = (0.04, 0.04, 0.04)
        cube_urdf = 'block/block.urdf'

        objs = []
        for i in range(12):
            cube_pose = self.get_random_pose(env, cube_size)
            cube_id = env.add_object(cube_urdf, cube_pose, color=colors[i%4])
            objs.append(cube_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos for pallet_pose in pallet_poses]

        # Goal: cubes are sorted by color and stacked in a pyramid in each pallet.
        for i in range(4):
            self.add_goal(objs=objs[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(color=list(utils.COLORS.keys())[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""ball-sorting-with-blocks-barrier"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [ball-sorting-with-blocks-barrier]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallSortingWithBlocksBarrier(Task):
    """"""Pick up each ball and place it into the zone of the same color, but without knocking over the blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} zone without knocking over the blocks""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the balls and zones
        colors = ['red', 'blue', 'green', 'yellow']

        # Add zones and blocks.
        zone_size = (0.12, 0.12, 0)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        zone_urdf = 'zone/zone.urdf'
        zones = []
        blocks = []
        for color in colors:
            # Add zone of specific color
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zones.append(zone_pose)

            # Add line of blocks of the same color
            for _ in range(5):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[color])
            balls.append(ball_id)

        # Goal: each ball is in a zone of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[zones[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-block-bridge"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-block-bridge]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBlockBridge(Task):
    """"""Construct a bridge by interleaving three differently colored blocks (red, blue, and green) on a pallet in a specific sequence - red block at the edges, blue block in the middle, and a green block on top of the red and blue blocks. Repeat this sequence until a bridge is formed across the length of the pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""construct a bridge by interleaving three differently colored blocks (red, blue, and green) on a pallet in a specific sequence""
        self.task_completed_desc = ""done constructing the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.30, 0.15, 0.02)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'

        objs = []
        for i in range(9):  # 3 sets of 3 colored blocks
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i % 3])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02),  # bottom layer
                     (0, -0.05, 0.06), (0, 0, 0.06), (0, 0.05, 0.06),  # middle layer
                     (0, -0.05, 0.10), (0, 0, 0.10), (0, 0.05, 0.10)]  # top layer
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a bridge (bottom layer: red, blue, red).
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (middle layer: green, green, green).
        self.add_goal(objs=objs[3:6], matches=np.ones((3, 3)), targ_poses=targs[3:6], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (top layer: red, blue, red).
        self.add_goal(objs=objs[6:], matches=np.ones((3, 3)), targ_poses=targs[6:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template) 

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-cylinder-pyramid"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-cylinder-pyramid]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedCylinderPyramid(Task):
    """"""Construct a pyramid on a pallet using four cylinders of different colors (red, blue, green, and yellow).""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""make the {row} row with {cylinder}""
        self.task_completed_desc = ""done stacking cylinder pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.005)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Cylinder colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            cylinders.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0.05, 0.03),
                     (0, 0, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: cylinders are stacked in a pyramid (bottom row: red, blue).
        self.add_goal(objs=cylinders[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                language_goal=self.lang_template.format(cylinder=""the red and blue cylinders"", row=""bottom""))

        # Goal: cylinders are stacked in a pyramid (middle row: green).
        self.add_goal(objs=cylinders[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*1,
                language_goal=self.lang_template.format(cylinder=""the green cylinder"", row=""middle""))

        # Goal: cylinders are stacked in a pyramid (top row: yellow).
        self.add_goal(objs=cylinders[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*1,
                language_goal=self.lang_template.format(cylinder=""the yellow cylinder"", row=""top""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sweep-and-sort-blocks"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sweep-and-sort-blocks]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class SweepAndSortBlocks(Task):
    """"""Sweep a pile of small blocks of different colors (red, blue, green, and yellow) into their corresponding colored zones marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""sweep the pile of {color} blocks into the {color} square""
        self.task_completed_desc = ""done sweeping and sorting.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add colored zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        zone_poses = []
        for color in colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add piles of colored blocks.
        block_urdf = 'block/small.urdf'
        block_size = (0.04, 0.04, 0.04)
        piles = []
        for color in colors:
            pile = []
            for _ in range(10):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                pile.append(block_id)
            piles.append(pile)

        # Add goals for each color.
        for i, color in enumerate(colors):
            self.add_goal(objs=piles[i], matches=np.ones((10, 1)), targ_poses=[zone_poses[i]], replace=True,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1,
                          language_goal=self.lang_template.format(color=color))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-cylinders-in-zones"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-cylinders-in-zones]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignCylindersInZones(Task):
    """"""Place four differently colored cylinders each into a matching colored zone. 
    The zones are surrounded by small blocks, which the robot needs to move out of the way 
    without knocking them out of their respective zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} cylinder in the {color} zone""
        self.task_completed_desc = ""done aligning cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Cylinder colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[colors[i]])
            cylinders.append(cylinder_id)

        # Add zones.
        # x, y, z dimensions for the asset size
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'

        zones = []
        for i in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, color=utils.COLORS[colors[i]], category='fixed')
            zones.append(zone_pose)

        # Add small blocks around the zones.
        # x, y, z dimensions for the asset size
        block_size = (0.02, 0.02, 0.02)
        block_urdf = 'block/small.urdf'

        for _ in range(16):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each cylinder is in a matching colored zone.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[zones[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sphere-container-color-match"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sphere-container-color-match]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SphereContainerColorMatch(Task):
    """"""Pick up each sphere and place it into a container of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 4
        self.lang_template = ""put the {color} sphere in the {color} container""
        self.task_completed_desc = ""done matching spheres and containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        containers = []
        for i in range(4):
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=colors[i])
            containers.append(container_id)

        # Add spheres.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for i in range(4):
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=colors[i])
            spheres.append(sphere_id)

        # Goal: each sphere is in a container of the same color.
        for i in range(4):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(containers[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insert-ell-along-square-path"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insert-ell-along-square-path]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class InsertEllAlongSquarePath(Task):
    """"""Pick up each ell block and insert it into the fixture of the same color. However, the robot must move each ell block along the marked square path to reach the fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the {color} ell block into the {color} fixture""
        self.task_completed_desc = ""done inserting ell blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Ell block colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add ell blocks and fixtures.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        fixture_urdf = 'insertion/fixture.urdf'
        ell_blocks = []
        fixtures = []
        for color in colors:
            # Add ell block
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ell_blocks.append(ell_id)

            # Add fixture
            fixture_pose = self.get_random_pose(env, ell_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

        # Goal: each ell block is inserted into the fixture of the same color.
        for i in range(len(colors)):
            self.add_goal(objs=[ell_blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))

        # Add square path marked by small blocks.
        path_block_size = (0.02, 0.02, 0.02)
        path_block_urdf = 'block/small.urdf'
        path_block_color = utils.COLORS['gray']
        for _ in range(16):
            path_block_pose = self.get_random_pose(env, path_block_size)
            env.add_object(path_block_urdf, path_block_pose, color=path_block_color)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-box-ball-matching"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-box-ball-matching]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBoxBallMatching(Task):
    """"""Pick up each ball and place it inside the box of the same color, navigate around the barrier without knocking over any small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} box""
        self.task_completed_desc = ""done placing balls in boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the boxes and balls
        colors = ['red', 'blue', 'green', 'yellow']

        # Add boxes.
        box_size = (0.05, 0.05, 0.05)
        box_urdf = 'box/box-template.urdf'
        box_poses = []
        for color in colors:
            box_pose = self.get_random_pose(env, box_size)
            env.add_object(box_urdf, box_pose, color=color, category='fixed')
            box_poses.append(box_pose)

        # Add balls.
        balls = []
        ball_size = (0.02, 0.02, 0.02)
        ball_urdf = 'ball/ball-template.urdf'
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add small blocks as barriers.
        barrier_size = (0.01, 0.01, 0.01)
        barrier_urdf = 'block/small.urdf'
        for _ in range(10):
            barrier_pose = self.get_random_pose(env, barrier_size)
            env.add_object(barrier_urdf, barrier_pose, category='fixed')

        # Goal: each ball is in the box of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[box_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""cylinder-balancing-and-placement"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [cylinder-balancing-and-placement]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderBalancingAndPlacement(Task):
    """"""Pick up each cylinder and balance it on its end at the center of the corresponding colored zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""balance the {color} cylinder in the {color} zone""
        self.task_completed_desc = ""done balancing and placing cylinders.""
        self.colors = ['red', 'green', 'blue']
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for color in self.colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.12)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in self.colors:
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[color])
            cylinders.append(cylinder_id)

        # Goal: each cylinder is balanced in the corresponding colored zone.
        for i in range(len(cylinders)):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=self.lang_template.format(color=self.colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-sphere-and-cylinder-assembly"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-sphere-and-cylinder-assembly]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedSphereAndCylinderAssembly(Task):
    """"""Pick up each sphere and place it on top of the cylinder of the same color, in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere on the {color} cylinder""
        self.task_completed_desc = ""done placing spheres on cylinders.""
        self.colors = ['red', 'blue', 'green', 'yellow']
        self.color_sequence = ['red', 'blue', 'green', 'yellow']

    def reset(self, env):
        super().reset(env)

        # Add spheres and cylinders.
        sphere_size = (0.05, 0.05, 0.05)
        cylinder_size = (0.05, 0.05, 0.1)
        sphere_template = 'sphere/sphere-template.urdf'
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Add spheres and cylinders of each color.
        for color in self.colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            sphere_id = env.add_object(sphere_template, sphere_pose, color=color)
            cylinder_id = env.add_object(cylinder_template, cylinder_pose, color=color)

            # Goal: each sphere is on top of the cylinder of the same color.
            self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[cylinder_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=color))

        # The task is completed in a specific color sequence.
        self.color_sequence = ['red', 'blue', 'green', 'yellow']
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sequential-block-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sequential-block-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SequentialBlockInsertion(Task):
    """"""Pick up blocks of different colors and insert them into the fixture of the same color in a specific sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the sequence of colors
        colors = ['red', 'blue', 'green', 'yellow']

        # Add fixtures.
        # x, y, z dimensions for the asset size
        fixture_size = (0.12, 0.12, 0)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""sequential-insertion-and-stacking"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [sequential-insertion-and-stacking]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SequentialInsertionAndStacking(Task):
    """"""Pick up and insert each ell block into the corresponding colored fixture in the sequence of red, blue, and green. After successful insertion, pick up the three blocks again from the fixtures and stack them in a corner of the tabletop in the same color sequence - red at the bottom, blue in the middle, and green on top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""insert the {color} ell block into the {color} fixture and then stack them in the corner""
        self.task_completed_desc = ""done inserting and stacking.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0)
        fixture_urdf = 'insertion/fixture.urdf'
        fixture_poses = []
        colors = ['red', 'blue', 'green']
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            env.add_object(fixture_urdf, fixture_pose, category='fixed', color=utils.COLORS[color])
            fixture_poses.append(fixture_pose)

        # Add ell blocks.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell block is in the corresponding colored fixture.
        for i in range(3):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[fixture_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/3)
            self.lang_goals.append(self.lang_template.format(color=colors[i]))

        # Add corner.
        corner_size = (0.12, 0.12, 0)
        corner_pose = self.get_random_pose(env, corner_size)
        corner_urdf = 'corner/corner-template.urdf'
        env.add_object(corner_urdf, corner_pose, category='fixed')

        # Goal: ell blocks are stacked in the corner in the color sequence - red at the bottom, blue in the middle, and green on top.
        stack_poses = [(0, 0, 0.04), (0, 0, 0.08), (0, 0, 0.12)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in stack_poses]
        self.add_goal(objs=ells, matches=np.ones((3, 3)), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=""stack the ell blocks in the corner in the color sequence - red at the bottom, blue in the middle, and green on top"")
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-block-shifting"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-block-shifting]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBlockShifting(Task):
    """"""Pick up each block and precisely place it in the zone of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""move the {color} blocks to the {color} zone""
        self.task_completed_desc = ""done moving blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_colors = ['yellow', 'blue', 'green']
        zone_poses = []
        for color in zone_colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in zone_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add small blocks as obstacles.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'stacking/block.urdf'
        for _ in range(5):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is in the zone of the same color.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/9,
                          language_goal=self.lang_template.format(color=zone_colors[i//3]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""guided-block-path"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [guided-block-path]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class GuidedBlockPath(Task):
    """"""Pick up each block and move it along the line of the same color from start to end.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the {color} block along the {color} line from start to end""
        self.task_completed_desc = ""done moving blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add lines and blocks.
        # x, y, z dimensions for the asset size
        line_size = (0.3, 0.01, 0.01)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        line_urdf = 'line/line-template.urdf'

        blocks = []
        lines = []
        for i in range(4):
            # Add line
            line_pose = self.get_random_pose(env, line_size)
            env.add_object(line_urdf, line_pose, color=colors[i], category='fixed')
            lines.append(line_pose)

            # Add block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

            # Add goal
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[line_pose], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""mixed-color-block-barrier-insertion"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [mixed-color-block-barrier-insertion]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MixedColorBlockBarrierInsertion(Task):
    """"""Pick up each colored block, navigate the barriers, and insert each block into the fixture of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and fixtures
        colors = ['red', 'blue', 'green', 'yellow']

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Add fixtures.
        fixture_size = (0.06, 0.06, 0.06)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

        # Add barriers.
        barrier_size = (0.12, 0.04, 0.04)
        barrier_colors = ['orange', 'purple', 'brown']
        for _ in range(2):
            for color in barrier_colors:
                barrier_pose = self.get_random_pose(env, barrier_size)
                env.add_object(block_urdf, barrier_pose, color=utils.COLORS[color])

        # Goal: each block is inserted into the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""ball-in-bowl-obstacle-course"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [ball-in-bowl-obstacle-course]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallInBowlObstacleCourse(Task):
    """"""Navigate through a maze of blocks, pick up balls of different colors and place them in the corresponding colored bowls.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""navigate through the maze and place the {color} ball in the {color} bowl""
        self.task_completed_desc = ""done placing balls in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks to form a maze.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(10):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose, category='fixed')

        # Add balls of different colors.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add bowls of different colors at different corners of the maze.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for color in colors:
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color, category='fixed')
            bowls.append(bowl_id)

        # Goal: each ball is in the bowl of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(bowls[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""ball-in-bowl-obstacle-course-new"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [ball-in-bowl-obstacle-course-new]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallInBowlObstacleCourseNew(Task):
    """"""Navigate through a maze of blocks, pick up balls of different colors and place them in the corresponding colored bowls.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} bowl""
        self.task_completed_desc = ""done placing balls in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks to form a maze.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(10):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose, category='fixed')

        # Add balls of different colors.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add bowls of different colors at different corners of the maze.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for color in colors:
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color, category='fixed')
            bowls.append(bowl_id)

        # Goal: each ball is in the bowl of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(bowls[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-arch-construction"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-arch-construction]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedArchConstruction(Task):
    """"""Construct an arch using six blocks: three red and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 6
        self.lang_template = ""construct an arch using six blocks: three red and three blue""
        self.task_completed_desc = ""done constructing arch.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.005)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue'],
                  utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue']]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02),
                     (0, 0, 0.06), (0, -0.05, 0.08),
                     (0, 0.05, 0.08), (0, 0, 0.12)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in an arch (bottom row: red, red, blue).
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)

        # Goal: blocks are stacked in an arch (top row: red, red, blue).
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-zone-arrangement"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-zone-arrangement]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedZoneArrangement(Task):
    """"""Pick up blocks of different colors and place them on the pallets of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {color} blocks on the {color} pallet""
        self.task_completed_desc = ""done arranging blocks on pallets.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.12, 0.12, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_colors = ['red', 'blue', 'green']
        pallet_poses = []
        for color in pallet_colors:
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed', color=utils.COLORS[color])
            pallet_poses.append(pallet_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        for color in pallet_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add small blocks as obstacles.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'block/small.urdf'
        for _ in range(5):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is on the pallet of the same color.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[pallet_poses[i // 3]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 9,
                          language_goal=self.lang_template.format(color=pallet_colors[i // 3]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-cylinder-stand-assembly"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-cylinder-stand-assembly]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedCylinderStandAssembly(Task):
    """"""Pick up each cylinder and place it on top of the stand of the same color, in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the {color} cylinder on the {color} stand""
        self.task_completed_desc = ""done placing cylinders on stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['green', 'yellow', 'blue', 'red']
        color_sequence = [utils.COLORS[color] for color in colors]

        # Add stands.
        stand_size = (0.04, 0.04, 0.04)
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i in range(4):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, color=color_sequence[i], category='fixed')
            stand_poses.append(stand_pose)

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color_sequence[i])
            cylinders.append(cylinder_id)

        # Goal: each cylinder is on the stand of the same color, in the specified color sequence.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[stand_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4, 
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-ball-stacking"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-ball-stacking]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBallStacking(Task):
    """"""Stack balls on top of the corresponding colored containers in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""stack the balls on top of the corresponding colored containers in the sequence blue, yellow, green, red""
        self.task_completed_desc = ""done stacking balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the color sequence
        color_sequence = ['blue', 'yellow', 'green', 'red']

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        container_poses = []
        containers = []
        for color in color_sequence:
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            container_poses.append(container_pose)
            containers.append(container_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in color_sequence:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[color])
            balls.append(ball_id)

        # Goal: each ball is stacked on top of the corresponding colored container in the color sequence.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[container_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                language_goal=self.lang_template.format(obj=color_sequence[i]))

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_ball = np.random.rand() > 0.5
            urdf = ball_urdf if is_ball else container_urdf
            size = ball_size if is_ball else container_size
            pose = self.get_random_pose(env, obj_size=size)
            color = np.random.choice(list(utils.COLORS.keys()))

            obj_id = env.add_object(urdf, pose, color=utils.COLORS[color])
            n_distractors += 1
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coded-blocks-on-corner"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coded-blocks-on-corner]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCodedBlocksOnCorner(Task):
    """"""Pick up blocks of different colors and place them in a corner structure in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the blocks in the corner in the sequence red, blue, green, yellow""
        self.task_completed_desc = ""done placing blocks in the corner.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corner structure.
        corner_size = (0.15, 0.15, 0.05)
        corner_pose = self.get_random_pose(env, corner_size)
        corner_urdf = 'corner/corner-template.urdf'
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0, 0.08)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in place_pos]

        # Goal: blocks are placed in the corner in the sequence red, blue, green, yellow.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, 
                    language_goal=self.lang_template.format(blocks=""the red, blue, green, yellow blocks""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""insertion-in-color-sequenced-zones"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [insertion-in-color-sequenced-zones]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertionInColorSequencedZones(Task):
    """"""Pick up each ell and place it in the zone of the same color, in the specific sequence of red, blue, green, and yellow from left to right.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ell in the {color} zone""
        self.task_completed_desc = ""done placing ells in color sequenced zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Ell colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add ells.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for i in range(4):
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[colors[i]])
            ells.append(ell_id)

        # Goal: each ell is in the zone of the same color.
        for i in range(4):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-zone-stacking"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-zone-stacking]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedZoneStacking(Task):
    """"""Pick up blocks of different colors and stack them in zones to form a pyramid.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""stack the blocks in the zones to form a pyramid""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(9):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i//3])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_poses[i//3], place_pos[i%3]), zone_poses[i//3][1]) for i in range(9)]

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(3):
            self.add_goal(objs=blocks[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the red, blue and green blocks"",
                                                             row=""bottom""))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-cylinder-ball-match"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-cylinder-ball-match]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedCylinderBallMatch(Task):
    """"""Pick up each ball and place it on top of the cylinder of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball on the {color} cylinder""
        self.task_completed_desc = ""done placing balls on cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_colors = ['red', 'blue', 'green', 'yellow']
        cylinder_poses = []
        cylinders = []
        for color in cylinder_colors:
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color)
            cylinder_poses.append(cylinder_pose)
            cylinders.append(cylinder_id)

        # Add balls.
        # x, y, z dimensions for the asset size
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in cylinder_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add blocks as obstacles.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(5):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each ball is on top of the cylinder of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                language_goal=self.lang_template.format(color=cylinder_colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""multi-level-insertion-and-zone-matching"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [multi-level-insertion-and-zone-matching]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class MultiLevelInsertionAndZoneMatching(Task):
    """"""Pick up ell objects from their current position and insert them into the corresponding colored zone on the same level, in a specific order - large, medium, and small.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {size} {color} ell into the {color} zone on the same level""
        self.task_completed_desc = ""done inserting.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_sizes = [(0.12, 0.12, 0), (0.12, 0.12, 0.05), (0.12, 0.12, 0.1)]
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        zone_colors = ['red', 'blue', 'green']
        for i in range(3):
            zone_pose = self.get_random_pose(env, zone_sizes[i])
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[zone_colors[i]])
            zone_poses.append(zone_pose)

        # Add ell objects.
        ell_sizes = [(0.08, 0.08, 0.02), (0.06, 0.06, 0.015), (0.04, 0.04, 0.01)]
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for i in range(3):
            for j in range(3):
                ell_pose = self.get_random_pose(env, ell_sizes[j])
                ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[zone_colors[i]])
                ells.append(ell_id)

        # Goal: each ell object is in the corresponding colored zone on the same level.
        for i in range(9):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/9,
                          language_goal=self.lang_template.format(size=['large', 'medium', 'small'][i%3], color=zone_colors[i//3]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-cued-ball-corner-sorting"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-cued-ball-corner-sorting]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCuedBallCornerSorting(Task):
    """"""Pick up each colored ball and place it in the corner of the same color while avoiding a zone marked by small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} corner""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corners.
        corner_size = (0.05, 0.05, 0.05)
        corner_urdf = 'corner/corner-template.urdf'
        corner_colors = ['red', 'blue', 'green', 'yellow']
        corner_poses = []
        for color in corner_colors:
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, color=color, category='fixed')
            corner_poses.append(corner_pose)

        # Add balls.
        balls = []
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        for color in corner_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add zone.
        zone_size = (0.2, 0.2, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block_for_anchors.urdf'
        for _ in range(4):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each ball is in the corner of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[corner_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=corner_colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""cylinder-ring-stack"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [cylinder-ring-stack]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderRingStack(Task):
    """"""Pick up each block and stack it on top of the corresponding colored cylinder. 
    Each cylinder and block pair should be stacked inside a differently colored container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the {color} block on the {color} cylinder in the {container_color} container""
        self.task_completed_desc = ""done stacking.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for cylinders, blocks and containers
        colors = ['red', 'blue', 'green', 'yellow']
        container_colors = ['blue', 'green', 'yellow', 'red']

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[colors[i]])
            cylinders.append(cylinder_id)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[colors[i]])
            blocks.append(block_id)

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        containers = []
        for i in range(4):
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[container_colors[i]])
            containers.append(container_id)

        # Goal: each block is stacked on the corresponding colored cylinder inside a differently colored container.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i], container_color=container_colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-coordinated-sphere-on-pallet-pyramid"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-coordinated-sphere-on-pallet-pyramid]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedSphereOnPalletPyramid(Task):
    """"""Build a pyramid of colored blocks on pallets and place a matching colored sphere on top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""build a pyramid of {color} blocks on the pallet and place the {color} sphere on top""
        self.task_completed_desc = ""done building color-coordinated pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Pallets and Blocks
        pallet_size = (0.15, 0.15, 0.01)
        block_size = (0.04, 0.04, 0.04)
        pallet_urdf = 'pallet/pallet.urdf'
        block_urdf = 'block/block.urdf'

        # Colors for blocks and spheres
        colors = ['red', 'blue', 'green']
        color_objects = {}

        # Add pallets and blocks
        for color in colors:
            # Add pallet
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed')

            # Add blocks
            block_ids = []
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                block_ids.append(block_id)

            color_objects[color] = {'pallet': pallet_pose, 'blocks': block_ids}

        # Spheres
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'

        # Add spheres
        for color in colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[color])
            color_objects[color]['sphere'] = sphere_id

        # Goals
        for color in colors:
            # Goal: blocks are stacked in a pyramid on the pallet
            block_poses = [(0, -0.02, 0.02), (0, 0.02, 0.02), (0, 0, 0.06)]
            targs = [(utils.apply(color_objects[color]['pallet'], i), color_objects[color]['pallet'][1]) for i in block_poses]

            self.add_goal(objs=color_objects[color]['blocks'], matches=np.ones((3, 3)), targ_poses=targs, replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                    language_goal=self.lang_template.format(color=color))

            # Goal: sphere is placed on top of the pyramid
            sphere_pose = (0, 0, 0.1)
            targ = (utils.apply(color_objects[color]['pallet'], sphere_pose), color_objects[color]['pallet'][1])

            self.add_goal(objs=[color_objects[color]['sphere']], matches=np.ones((1, 1)), targ_poses=[targ], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(color=color))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-sequenced-sphere-placement"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-sequenced-sphere-placement]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSequencedSpherePlacement(Task):
    """"""Pick up spheres of different colors and place them in the center of the square of the same color in a specific sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere in the {color} square""
        self.task_completed_desc = ""done placing spheres.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add squares of different colors
        square_size = (0.1, 0.1, 0.005)
        square_urdf = 'square/square-template.urdf'
        square_poses = []
        for color in colors:
            square_pose = self.get_random_pose(env, square_size)
            env.add_object(square_urdf, square_pose, 'fixed', color=color)
            square_poses.append(square_pose)

        # Add spheres of different colors
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for color in colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=color)
            spheres.append(sphere_id)

        # Goal: each sphere is in the square of the same color, in the correct sequence
        for i in range(len(colors)):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[square_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""color-ordered-insertion-new"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [color-ordered-insertion-new]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedInsertionNew(Task):
    """"""Insert differently-colored ell objects into the matching color fixture in a specific order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']
        color_order = {color: i for i, color in enumerate(colors)}

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0.02)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add ell objects.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell is inserted into the matching color fixture in the correct order.
        for i, ell in enumerate(ells):
            self.add_goal(objs=[ell], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(ells),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""put-blocks-between-zones"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [put-blocks-between-zones]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import copy

class PutBlocksBetweenZones(Task):
    """"""Arrange four differently colored blocks (red, blue, green, and yellow) between two designated zones on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Arrange the blocks between the zones in the order: red, blue, green, yellow""
        self.task_completed_desc = ""done arranging blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone1_pose = self.get_random_pose(env, zone_size)
        zone2_pose = copy.deepcopy(zone1_pose)
        zone2_pose = (utils.apply(zone1_pose, (0,0.1,0)), zone2_pose[1])
        env.add_object(zone_urdf, zone1_pose, 'fixed')
        env.add_object(zone_urdf, zone2_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Goal: blocks are arranged between the zones in the order: red, blue, green, yellow.
        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0.1, 0.03)]
        targs = [(utils.apply(zone1_pose, i), zone1_pose[1]) for i in place_pos]

        # Add goal
        self.add_goal(objs=blocks, matches=np.ones((4, 4)), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, symmetries=[np.pi/2]*4, language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""put-blues-around-red"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [put-blues-around-red]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PlaceBluesAroundRed(Task):
    """"""Pick up the blue blocks one by one and place them around the red block, forming a circle.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the blue blocks around the red block""
        self.task_completed_desc = ""done placing blue blocks around red block.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add red block.
        red_block_size = (0.04, 0.04, 0.04)
        red_block_urdf = 'block/block_for_anchors.urdf'
        red_block_pose = self.get_random_pose(env, red_block_size)
        red_block_id = env.add_object(red_block_urdf, red_block_pose, 'fixed')

        # Add blue blocks.
        blue_blocks = []
        blue_block_size = (0.02, 0.02, 0.02)
        blue_block_urdf = 'block/block_for_anchors.urdf'
        N = 4

        for _ in range(N):
            blue_block_pose = self.get_random_pose(env, blue_block_size)
            blue_block_id = env.add_object(blue_block_urdf, blue_block_pose, color=utils.COLORS['blue'])
            blue_blocks.append(blue_block_id)

        # Calculate target poses for blue blocks to form a circle around the red block.
        radius = 0.06  # radius of the circle
        angles = np.linspace(0, 2*np.pi, N, endpoint=False)  # angles for each blue block
        targ_poses = []
        for angle in angles:
            x = red_block_pose[0][0] + radius * np.cos(angle)
            y = red_block_pose[0][1] + radius * np.sin(angle)
            z = red_block_pose[0][2]
            targ_poses.append(((x, y, z), red_block_pose[1]))

            # Add goal.
            self.add_goal(objs=blue_blocks, matches=np.eye(N), targ_poses=targ_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1., language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""place-blue-on-line-ends"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [place-blue-on-line-ends]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PlaceBlueOnLineEnds(Task):
    """"""Pick up each blue box and accurately place it at the end of a green line.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the blue box at the end of the green line""
        self.task_completed_desc = ""done placing blue boxes on line ends.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add lines.
        line_size = (0.3, 0.01, 0.01)
        line_template = 'line/line-template.urdf'
        replace = {'DIM': line_size}
        line_urdf = self.fill_template(line_template, replace)

        line_colors = ['green']
        line_poses = []

        line_pose = self.get_random_pose(env, line_size)
        color = utils.COLORS[line_colors[0]]
        env.add_object(line_urdf, line_pose, 'fixed', color=color)
        line_poses.append(utils.apply(line_pose, (-0.15,0,0)))
        line_poses.append(utils.apply(line_pose, (0.15,0,0)))

        # Add blue boxes.
        box_size = (0.04, 0.04, 0.04)
        box_urdf = 'box/box-template.urdf'
        box_color = utils.COLORS['blue']
        boxes = []
        for _ in range(2):
            box_pose = self.get_random_pose(env, box_size)
            box_id = env.add_object(box_urdf, box_pose, color=box_color)
            boxes.append(box_id)

        # Goal: each blue box is at the end of a different colored line.
        for i in range(2):
            language_goal = self.lang_template.format(line_colors[0])
            self.add_goal(objs=[boxes[i]], matches=np.ones((1, 1)), targ_poses=[line_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=language_goal)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""ball-on-box-on-container"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [ball-on-box-on-container]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BallOnBoxOnContainer(Task):
    """"""Pick up each ball and place it on the corresponding colored box, which are located in specific positions on a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {} box on the container""
        self.lang_template_2 = ""place the {} ball on the {} box""

        self.task_completed_desc = ""done placing balls on boxs and box on container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        container_size = (0.2, 0.2, 0.06)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)

        env.add_object(container_urdf, container_pose, 'fixed')

        # Define colors.
        ball_colors = ['red']
        box_colors = ['blue']

        # Add boxs.
        box_size = (0.04, 0.04, 0.06)
        box_template = 'box/box-template.urdf'
        boxs = []


        replace = {'DIM': box_size, 'HALF': (box_size[0] / 2, box_size[1] / 2, box_size[2] / 2), 'COLOR': ball_colors[0]}
        box_urdf = self.fill_template(box_template, replace)
        box_pose = self.get_random_pose(env, box_size)
        box_id = env.add_object(box_urdf, box_pose)
        boxs.append(box_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball.urdf'
        balls = []
        ball_pose = self.get_random_pose(env, ball_size)
        ball_id = env.add_object(ball_urdf, ball_pose, color=box_colors[0])
        balls.append(ball_id)

        # Goal: place the box on top of the container
        self.add_goal(objs=[boxs[0]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=self.lang_template.format(box_colors[0]))


        # Goal: place the ball on top of the box
        language_goal = self.lang_template_2.format(ball_colors[0], box_colors[0])
        self.add_goal(objs=[balls[0]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=language_goal)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-rope-along-line"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-rope-along-line]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class AlignRopeAlongLine(Task):
    """"""Align a deformable rope along a straight line marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope along the line""
        self.task_completed_desc = ""done aligning.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add line.
        length = np.random.uniform(0.18, 0.25)
        line_size = (length, 0.01, 0.01)
        line_pose = self.get_random_pose(env, line_size)
        line_template = 'line/line-template.urdf'
        replace = {'DIM': line_size, 'HALF': (line_size[0] / 2, line_size[1] / 2, line_size[2] / 2)}
        line_urdf = self.fill_template(line_template, replace)
        env.add_object(line_urdf, line_pose, 'fixed')

        # Add rope.
        rope_size  = (length, 0.01, 0.01)
        rope_pose = self.get_random_pose(env, rope_size)
        corner1_pose = utils.apply(line_pose, (length / 2, 0.01, 0.01))
        corner2_pose = utils.apply(line_pose, (-length / 2, 0.01, 0.01))
        rope_id, targets, matches = self.make_rope(env, (corner1_pose, corner2_pose), n_parts=15)

        # Goal: rope is aligned with the line.
        self.add_goal(objs=rope_id, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""align-rope-cross-zone"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [align-rope-cross-zone]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class AlignRopeCrossZone(Task):
    """"""Align a deformable rope across the diagonal of a zone marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope across the diagonal of a zone""
        self.task_completed_desc = ""done aligning.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zone.
        length = 0.12
        zone_size = (length, length, 0.01)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add rope.
        rope_size  = (length, 0.01, 0.01)
        rope_pose = self.get_random_pose(env, rope_size)
        corner1_pose = utils.apply(zone_pose, (length / 2, length / 2, 0.01))
        corner2_pose = utils.apply(zone_pose, (-length / 2, -length / 2, 0.01))
        rope_id, targets, matches = self.make_rope(env, (corner1_pose, corner2_pose), n_parts=10)

        # Goal: rope is aligned with the diagonal of the zone.
        self.add_goal(objs=rope_id, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""put-kit-in-bowl"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [put-kit-in-bowl]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os


class PutKitInBowl(Task):
    """"""Place the specific kit in a bowl of specified color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} in a {place} bowl""
        self.task_completed_desc = ""done placing kit in bowls.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_objects = np.random.randint(1, n_bowls + 1)
        colors, selected_color_names = utils.get_colors(mode=self.mode, n_colors=2)
        block_urdf = 'stacking/block.urdf'
        block_size = (0.04, 0.04, 0.04)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, category='fixed', color=colors[1])
            bowl_poses.append(bowl_pose)

        # Add kits.
        objects_ids = []
        obj_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_objects):
            scale = utils.map_kit_scale((0.03, 0.03, 0.02))
            shape = os.path.join(self.assets_root, 'kitting',
                                     f'{obj_shapes[i]:02d}.obj')
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[0]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            obj_pose = self.get_random_pose(env, block_size)
            obj_id = env.add_object(urdf, obj_pose)
            objects_ids.append(obj_id)

            # Goal: put each block in a different bowl.
            pick_name = selected_color_names[0] + "" "" + utils.assembling_kit_shapes[obj_shapes[i]]
            language_goal = (self.lang_template.format(pick=pick_name, place=selected_color_names[1]))
            self.add_goal(objs=[obj_id], matches=np.ones((1, 1)), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

        # Only one mistake allowed.
        self.max_steps = len(objects_ids) + 1

        # Colors of distractor objects.
        distractor_bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c not in selected_color_names]
        distractor_block_colors = [utils.COLORS[c] for c in utils.COLORS if c not in selected_color_names]

        # Add distractors.
        n_distractors = 0
        max_distractors = 6
        while n_distractors < max_distractors:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = distractor_block_colors if is_block else distractor_bowl_colors
            pose = self.get_random_pose(env, size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""kit-in-bowl-in-zone"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [kit-in-bowl-in-zone]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import os

class KitInBowlInZone(Task):
    """"""Pick up each kit and place it on the corresponding colored bowl, which are located in specific positions on a zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {} bowl on the zone""
        self.lang_template_2 = ""place the {} on the {} bowl""

        self.task_completed_desc = ""done placing kits on bowls and bowl on zone.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zone.
        zone_size = (0.2, 0.2, 0.01)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Define colors.
        kit_colors = ['red']
        bowl_colors = ['blue']

        # Add bowls.
        bowl_size = (0.04, 0.04, 0.06)
        bowls = []
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_id = env.add_object(bowl_urdf, bowl_pose)
        bowls.append(bowl_id)

        # Add kits.
        kit_size = utils.map_kit_scale((0.03, 0.03, 0.02))
        obj_shapes = self.get_kitting_shapes(1)
        shape = os.path.join(self.assets_root, 'kitting',
                                 f'{obj_shapes[0]:02d}.obj')
        template = 'kitting/object-template.urdf'
        replace = {'FNAME': (shape,), 'SCALE': kit_size, 'COLOR': kit_colors[0]}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        kit_urdf = self.fill_template(template, replace)
        kits = []
        kit_pose = self.get_random_pose(env, kit_size)
        kit_id = env.add_object(kit_urdf, kit_pose, color=bowl_colors[0])
        kits.append(kit_id)

        # Goal: place the bowl on top of the zone
        self.add_goal(objs=[bowls[0]], matches=np.ones((1, 1)), targ_poses=[zone_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=self.lang_template.format(bowl_colors[0]))


        # Goal: place the kit on top of the bowl
        pick_name = kit_colors[0] + "" "" + utils.assembling_kit_shapes[obj_shapes[0]]
        language_goal = self.lang_template_2.format(pick_name, bowl_colors[0])
        self.add_goal(objs=[kits[0]], matches=np.ones((1, 1)), targ_poses=[zone_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=language_goal)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""move-kit-from-zone-to-cylinder"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [move-kit-from-zone-to-cylinder]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os
import copy

class MoveKitFromZoneToCylinder(Task):
    """"""Place the specific kit from a zone to a cylinder.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} from zone to {place} cylinder.""
        self.task_completed_desc = ""done placing kit in zones.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_zones = 3
        n_objects = 3
        colors, color_names = utils.get_colors(mode=self.mode, n_colors=n_objects)

        # Add zones and objects
        # x, y, z dimensions for the asset size
        cylinder_size = (0.12, 0.12, 0)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []

        zone_size = (0.06, 0.06, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        objects_ids = []
        obj_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_zones):
            # add zone
            zone_pose = self.get_random_pose(env, zone_size)
            zone_id = env.add_object(zone_urdf, zone_pose, category='fixed', color=colors[i])
            zone_poses.append(zone_pose)

            # add kit
            scale = utils.map_kit_scale((0.03, 0.03, 0.02))
            shape = os.path.join(self.assets_root, 'kitting',
                                     f'{obj_shapes[i]:02d}.obj')
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            obj_pose = zone_pose
            obj_id = env.add_object(urdf, obj_pose)
            objects_ids.append(obj_id)

            # add cylinder
            cylinder_pose = self.get_random_pose(env, zone_size)
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, category='fixed', color=colors[i])
            cylinder_poses.append(cylinder_pose)

        # Goal: put a specific kit from a zone to the top of a cylinder
        target_idx = np.random.randint(n_zones)
        pick_name = color_names[target_idx] + "" "" + utils.assembling_kit_shapes[obj_shapes[target_idx]]
        language_goal = (self.lang_template.format(pick=pick_name, place=color_names[target_idx]))
        self.add_goal(objs=[objects_ids[target_idx]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[target_idx]], replace=False,
            rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

```

###"
"I will provide you reference code for the task 'block-insertion' and you can write the code for the task ""move-bowl-from-pallet-to-corner"".

""""""
class BlockInsertion(Task):
    """"""pick up the L-shaped red block and place it into the L-shaped fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""put the L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def get_random_pose(self, env, obj_size):
        pose = super().get_random_pose(env, obj_size)
        pos, rot = pose
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        return pos, rot

    def reset(self, env):
        super().reset(env)

        """"""Add L-shaped block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/ell.urdf'
        pose = self.get_random_pose(env, size)
        block_id = env.add_object(urdf, pose)

        """"""Add L-shaped fixture to place block.""""""
        size = (0.1, 0.1, 0.04)
        urdf = 'insertion/fixture.urdf'
        targ_pose = self.get_random_pose(env, size)
        env.add_object(urdf, targ_pose, 'fixed')

        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)
""""""


Now write the pybullet simulation task class [move-bowl-from-pallet-to-corner]. Provide answers in a python code block starting with ```python
","
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os
import copy

class MoveBowlFromPalletToCorner(Task):
    """"""Place the specific bowl from a pallet to a corner.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} from pallet to {place} corner.""
        self.task_completed_desc = ""done placing bowl around corner.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_pallets = 3
        n_objects = 3
        colors, color_names = utils.get_colors(mode=self.mode, n_colors=n_objects)
        # Add pallets and objects
        # x, y, z dimensions for the asset size
        corner_size = (0.12, 0.12, 0)
        corner_urdf = 'corner/corner-template.urdf'
        corner_poses = []

        pallet_size = (0.06, 0.06, 0)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        objects_ids = []
        bowl_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_pallets):
            # add pallet
            pallet_pose = self.get_random_pose(env, pallet_size)
            pallet_id = env.add_object(pallet_urdf, pallet_pose, category='fixed', color=colors[i])
            pallet_poses.append(pallet_pose)

            # add kit
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_pose = pallet_pose
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=colors[i])
            objects_ids.append(bowl_id)

            # add corner
            corner_pose = self.get_random_pose(env, pallet_size)
            corner_id = env.add_object(corner_urdf, corner_pose, category='fixed', color=colors[i])
            corner_poses.append(corner_pose)

        # Goal: put a specific kit from a pallet to the top of a corner
        target_idx = np.random.randint(n_pallets)
        pick_name = color_names[target_idx] + "" "" + 'bowl'
        language_goal = (self.lang_template.format(pick=pick_name, place=color_names[target_idx]))
        self.add_goal(objs=[objects_ids[target_idx]], matches=np.ones((1, 1)), targ_poses=[corner_poses[target_idx]], replace=False,
            rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

```

###"
