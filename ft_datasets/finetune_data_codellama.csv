prompt,completion
"Write the pybullet simulation code for the task ""align-box-corner"" in a python code block.
###

"," 
 align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}```

###
```python
import os
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class AlignBoxCorner(Task):
    """"""Pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 3
        self.lang_template = ""align the brown box with the green corner""
        self.task_completed_desc = ""done with alignment""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Generate randomly shaped box.
        box_size = self.get_random_size(0.05, 0.15, 0.05, 0.15, 0.01, 0.06)

        # Add corner.
        dimx = (box_size[0] / 2 - 0.025 + 0.0025, box_size[0] / 2 + 0.0025)
        dimy = (box_size[1] / 2 + 0.0025, box_size[1] / 2 - 0.025 + 0.0025)
        corner_template = 'corner/corner-template.urdf'
        replace = {'DIMX': dimx, 'DIMY': dimy}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        corner_urdf = self.fill_template(corner_template, replace)
        corner_size = (box_size[0], box_size[1], 0)
        corner_pose = self.get_random_pose(env, corner_size)
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Add possible placing poses.
        theta = utils.quatXYZW_to_eulerXYZ(corner_pose[1])[2]
        fip_rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta + np.pi))
        pose1 = (corner_pose[0], fip_rot)
        alt_x = (box_size[0] / 2) - (box_size[1] / 2)
        alt_y = (box_size[1] / 2) - (box_size[0] / 2)
        alt_pos = (alt_x, alt_y, 0)
        alt_rot0 = utils.eulerXYZ_to_quatXYZW((0, 0, np.pi / 2))
        alt_rot1 = utils.eulerXYZ_to_quatXYZW((0, 0, 3 * np.pi / 2))
        pose2 = utils.multiply(corner_pose, (alt_pos, alt_rot0))
        pose3 = utils.multiply(corner_pose, (alt_pos, alt_rot1))

        # Add box.
        box_template = 'box/box-template.urdf'

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        box_urdf = self.fill_template(box_template, {'DIM': np.float32(box_size)})
        box_pose = self.get_random_pose(env, box_size)
        box_id = env.add_object(box_urdf, box_pose)
        self.color_random_brown(box_id)

        # Goal: box is aligned with corner (1 of 4 possible poses).
        self.add_goal(objs=[box_id], matches=np.int32([[1, 1, 1, 1]]), targ_poses=[corner_pose, pose1, pose2, pose3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, symmetries=[2 * np.pi],
                language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""align-rope"" in a python code block.
###

"," 
 align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}```

###
```python
import os

import numpy as np
from cliport.tasks import primitives
from cliport.tasks.task import Task
from cliport.utils import utils

import random
import pybullet as p


class AlignRope(Task):
    """"""Manipulate a deformable rope to connect its end-points between two 
    corners of a 3-sided square.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope from {direction}""
        self.task_completed_desc = ""done aligning the rope.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square.
        square_size = (length, length, 0)
        square_pose = self.get_random_pose(env, square_size)
        square_template = 'square/square-template.urdf'
        replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        urdf = self.fill_template(square_template, replace)
        env.add_object(urdf, square_pose, 'fixed')

        # Get four corner points of square.
        corner0 = ( length / 2,  length / 2, 0.001)
        corner1 = (-length / 2,  length / 2, 0.001)
        corner2 = ( length / 2, -length / 2, 0.001)
        corner3 = (-length / 2, -length / 2, 0.001)

        corner0 = utils.apply(square_pose, corner0)
        corner1 = utils.apply(square_pose, corner1)
        corner2 = utils.apply(square_pose, corner2)
        corner3 = utils.apply(square_pose, corner3)
        
        # Four possible alignment tasks.
        task_descs = [
            ((corner0, corner1), ""front left tip to front right tip""),
            ((corner0, corner2), ""front right tip to back right corner""),
            ((corner1, corner3), ""front left tip to back left corner""),
            ((corner3, corner2), ""back right corner to back left corner"")
        ]
        chosen_task = np.random.choice(len(task_descs), 1)[0]
        (corner_0, corner_1), direction = task_descs[chosen_task]

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1))
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1.,
                language_goal=[self.lang_template.format(direction=direction)] * len(objects))

        # wait for the scene to settle down
        for i in range(480):
            p.stepSimulation()
```

###"
"Write the pybullet simulation code for the task ""assembling-kits"" in a python code block.
###

"," 
 assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}```

###
```python
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class AssemblingKits(Task):
    """"""pick up different objects and arrange them on a board marked with corresponding silhouettes.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.homogeneous = False

        self.lang_template = ""put all the blocks inside the holes they fit in""
        self.task_completed_desc = ""done assembling blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add kit.
        kit_size = (0.28, 0.2, 0.005)
        kit_urdf = 'kitting/kit.urdf'
        kit_pose = self.get_random_pose(env, kit_size)
        env.add_object(kit_urdf, kit_pose, 'fixed')

        n_objects = 5
        obj_shapes = self.get_kitting_shapes(n_objects)
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['red']
        ]

        # Build kit.
        targets = []
        targ_pos = [[-0.09, 0.045, 0.0014], [0, 0.045, 0.0014],
                    [0.09, 0.045, 0.0014], [-0.045, -0.045, 0.0014],
                    [0.045, -0.045, 0.0014]]
        template = 'kitting/object-template.urdf'

        for i in range(n_objects):
            shape = os.path.join(self.assets_root, 'kitting',
                                 f'{obj_shapes[i]:02d}.obj')
            scale = [0.003, 0.003, 0.0001]  # .0005
            pos = utils.apply(kit_pose, targ_pos[i])
            theta = np.random.rand() * 2 * np.pi
            rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': [0.2, 0.2, 0.2]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            env.add_object(urdf, (pos, rot), 'fixed')
            targets.append((pos, rot))

        # Add objects.
        objects, matches = self.make_kitting_objects(env, targets=targets, obj_shapes=obj_shapes, n_objects=n_objects, colors=colors)
        matches = np.int32(matches)
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)
 
```

###"
"Write the pybullet simulation code for the task ""manipulating-rope"" in a python code block.
###

"," 
 manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}```

###
```python
import os

import numpy as np
from cliport.tasks import primitives
from cliport.tasks.task import Task
from cliport.utils import utils

import pybullet as p


class ManipulatingRope(Task):
    """"""rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""manipulate the rope to complete the square""
        self.task_completed_desc = ""done manipulating the rope.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square.
        square_size = (length, length, 0)
        square_pose = self.get_random_pose(env, square_size)
        square_template = 'square/square-template.urdf'

        # IMPORTANT: REPLACE THE TEMPLATE URDF  with `fill_template`
        replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}
        urdf = self.fill_template(square_template, replace)
        env.add_object(urdf, square_pose, 'fixed')

        # compute corners
        corner0 = (length / 2, length / 2, 0.001)
        corner1 = (-length / 2, length / 2, 0.001)
        corner_0 = utils.apply(square_pose, corner0)
        corner_1 = utils.apply(square_pose, corner1)

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1))
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1., lang_goal=self.lang_template)

        for i in range(480):
            p.stepSimulation()

```

###"
"Write the pybullet simulation code for the task ""packing-boxes"" in a python code block.
###

"," 
 packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}```

###
```python
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

import pybullet as p


class PackingBoxes(Task):
    """"""pick up randomly sized boxes and place them tightly into a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""pack all the boxes inside the brown box""
        self.task_completed_desc = ""done packing boxes.""

        self.zone_bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.08]])
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container box.
        zone_size = self.get_random_size(0.05, 0.3, 0.05, 0.3, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        margin = 0.01
        min_object_dim = 0.05
        bboxes = []

        # Split container space with KD trees.
        stack_size = np.array(zone_size)
        stack_size[0] -= 0.01
        stack_size[1] -= 0.01
        root_size = (0.01, 0.01, 0) + tuple(stack_size)
        root = utils.TreeNode(None, [], bbox=np.array(root_size))
        utils.KDTree(root, min_object_dim, margin, bboxes)

        colors = [utils.COLORS[c] for c in utils.COLORS if c != 'brown']

        # Add objects in container.
        object_ids = []
        bboxes = np.array(bboxes)
        object_template = 'box/box-template.urdf'

        # Compute object points that are needed for zone
        for bbox in bboxes:
            size = bbox[3:] - bbox[:3]
            position = size / 2. + bbox[:3]
            position[0] += -zone_size[0] / 2
            position[1] += -zone_size[1] / 2
            pose = (position, (0, 0, 0, 1))
            pose = utils.multiply(zone_pose, pose)

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(object_template, {'DIM': size})
            icolor = np.random.choice(range(len(colors)), 1).squeeze()
            box_id = env.add_object(urdf, pose, color=colors[icolor])
            object_ids.append(box_id)

        # Randomly select object in box and save ground truth pose.
        object_volumes = []
        true_poses = []

        for object_id in object_ids:
            true_pose = p.getBasePositionAndOrientation(object_id)
            object_size = p.getVisualShapeData(object_id)[0][3]
            object_volumes.append(np.prod(np.array(object_size) * 100))
            pose = self.get_random_pose(env, object_size)
            p.resetBasePositionAndOrientation(object_id, pose[0], pose[1])
            true_poses.append(true_pose)

        self.add_goal(objs=object_ids, matches=np.eye(len(object_ids)), targ_poses=true_poses, replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""palletizing-boxes"" in a python code block.
###

"," 
 palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}```

###
```python
import os
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PalletizingBoxes(Task):
    """"""Pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 30
        self.lang_template = ""stack all the boxes on the pallet""
        self.task_completed_desc = ""done stacking boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        zone_size = (0.3, 0.25, 0.25)
        zone_urdf = 'pallet/pallet.urdf'
        rotation = utils.eulerXYZ_to_quatXYZW((0, 0, 0))
        zone_pose = ((0.5, 0.25, 0.02), rotation)
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add stack of boxes on pallet.
        margin = 0.01
        object_ids = []

        # x, y, z dimensions for the asset size
        stack_size = (0.19, 0.19, 0.19)
        box_template = 'box/box-template.urdf'
        stack_dim = np.int32([2, 3, 3])

        box_size = (stack_size - (stack_dim - 1) * margin) / stack_dim
        for z in range(stack_dim[2]):

            # Transpose every layer.
            stack_dim[0], stack_dim[1] = stack_dim[1], stack_dim[0]
            box_size[0], box_size[1] = box_size[1], box_size[0]

            # IMPORTANT: Compute object points and store as a dictionary for the `goal`
            for y in range(stack_dim[1]):
                for x in range(stack_dim[0]):
                    position = list((x + 0.5, y + 0.5, z + 0.5) * box_size)
                    position[0] += x * margin - stack_size[0] / 2
                    position[1] += y * margin - stack_size[1] / 2
                    position[2] += z * margin + 0.03
                    pose = (position, (0, 0, 0, 1))
                    pose = utils.multiply(zone_pose, pose)

                    # IMPORTANT: REPLACE THE TEMPLATE URDF
                    urdf = self.fill_template(box_template, {'DIM': box_size})
                    box_id = env.add_object(urdf, pose)
                    object_ids.append(box_id)
                    self.color_random_brown(box_id)

        # Randomly select top box on pallet and save ground truth pose.
        targets = []
        self.steps = []
        boxes = object_ids[:] # make copy
        while boxes:
            _, height, object_mask = self.get_true_image(env)
            top = np.argwhere(height > (np.max(height) - 0.03))
            rpixel = top[int(np.floor(np.random.random() * len(top)))]  # y, x
            box_id = int(object_mask[rpixel[0], rpixel[1]])
            if box_id in boxes:
                position, rotation = p.getBasePositionAndOrientation(box_id)
                rposition = np.float32(position) + np.float32([0, -10, 0])
                p.resetBasePositionAndOrientation(box_id, rposition, rotation)
                self.steps.append(box_id)
                targets.append((position, rotation))
                boxes.remove(box_id)

        self.steps.reverse()  # Time-reversed depalletizing.
        self.add_goal(objs=object_ids, matches=np.eye(len(object_ids)), targ_poses=targets, replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
        self.spawn_box()

    def reward(self):
        reward, info = super().reward()
        self.spawn_box()
        return reward, info
```

###"
"Write the pybullet simulation code for the task ""place-red-in-green"" in a python code block.
###

"," 
 place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """"""pick up the red blocks and place them into the green bowls amidst other objects.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the red blocks in a green bowl""
        self.task_completed_desc = ""done placing blocks in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1

```

###"
"Write the pybullet simulation code for the task ""stack-block-pyramid"" in a python code block.
###

"," 
 stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """"""Build a pyramid of colored blocks in a color sequence""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""make the {row} row with {blocks}""
        self.task_completed_desc = ""done stacking block pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks=""the green, blue and purple blocks"", row=""bottom"")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks=""the yellow and orange blocks"", row=""middle"")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks=""the red block"", row=""top"")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
```

###"
"Write the pybullet simulation code for the task ""sweeping-piles"" in a python code block.
###

"," 
 sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}```

###
```python
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """"""Push piles of small objects into a target goal zone marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""push the pile of blocks into the green square""
        self.task_completed_desc = ""done sweeping.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""build-wheel"" in a python code block.
###

"," 
 build-wheel: {'task-name': 'build-wheel', 'task-description': 'Construct a wheel using blocks and a sphere. First, position eight blocks in a circular layout on the tabletop. Each block should be touching its two neighbors and colored in alternating red and blue. Then place a green sphere in the center of the circular layout, completing the wheel.', 'assets-used': ['block/block.urdf', 'sphere/sphere.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildWheel(Task):
    """"""Construct a wheel using blocks and a sphere.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Construct a wheel using blocks and a sphere. First, position eight blocks in a circular layout on the tabletop. Each block should be touching its two neighbors and colored in alternating red and blue. Then place a green sphere in the center of the circular layout, completing the wheel.""
        self.task_completed_desc = ""done building wheel.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i % 2])
            blocks.append(block_id)

        # Add sphere.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_color = utils.COLORS['green']
        sphere_pose = ((0.5, 0.0, 0.0), (0,0,0,1)) # fixed pose
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=sphere_color)

        # Goal: blocks are arranged in a circle and sphere is in the center.
        circle_radius = 0.1
        circle_center = (0, 0, block_size[2] / 2)
        angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)
        block_poses = [(circle_center[0] + circle_radius * np.cos(angle),
                        circle_center[1] + circle_radius * np.sin(angle),
                        circle_center[2]) for angle in angles]
        block_poses = [(utils.apply(sphere_pose, pos), sphere_pose[1]) for pos in block_poses]
        self.add_goal(objs=blocks, matches=np.ones((8, 8)), targ_poses=block_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=8 / 9, language_goal=self.lang_template)

        # Goal: sphere is in the center of the blocks.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[sphere_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1 / 9, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""push-piles-into-letter"" in a python code block.
###

"," 
 push-piles-into-letter: {'task-name': 'push-piles-into-letter', 'task-description': 'Push piles of small objects into a target goal zone shaped in some letters.', 'assets-used': ['kitting/kit.urdf', 'kitting/object-template-nocollision.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildWheel(Task):
    """"""Construct a wheel using blocks and a sphere.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Construct a wheel using blocks and a sphere. First, position eight blocks in a circular layout on the tabletop. Each block should be touching its two neighbors and colored in alternating red and blue. Then place a green sphere in the center of the circular layout, completing the wheel.""
        self.task_completed_desc = ""done building wheel.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i % 2])
            blocks.append(block_id)

        # Add sphere.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_color = utils.COLORS['green']
        sphere_pose = ((0.5, 0.0, 0.0), (0,0,0,1)) # fixed pose
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=sphere_color)

        # Goal: blocks are arranged in a circle and sphere is in the center.
        circle_radius = 0.1
        circle_center = (0, 0, block_size[2] / 2)
        angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)
        block_poses = [(circle_center[0] + circle_radius * np.cos(angle),
                        circle_center[1] + circle_radius * np.sin(angle),
                        circle_center[2]) for angle in angles]
        block_poses = [(utils.apply(sphere_pose, pos), sphere_pose[1]) for pos in block_poses]
        self.add_goal(objs=blocks, matches=np.ones((8, 8)), targ_poses=block_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=8 / 9, language_goal=self.lang_template)

        # Goal: sphere is in the center of the blocks.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[sphere_pose], replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1 / 9, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""connect-boxes-with-rope"" in a python code block.
###

"," 
 connect-boxes-with-rope: {'task-name': 'connect-boxes-with-rope', 'task-description': 'Connect two colored blocks with ropes.', 'assets-used': ['block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import IPython

class ConnectBoxesWithRope(Task):
    """"""Connect two colored blocks with ropes.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""connect the {color1} and {color2} blocks with the rope.""
        self.task_completed_desc = ""done connecting.""
        self.additional_reset()
        self.pos_eps = 0.04 # higher tolerance

    def reset(self, env):
        super().reset(env)
        colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        blocks = []
        target_colors = np.random.choice(colors, 2, replace=False)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        corner_poses = []

        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)
            if color in target_colors:
                corner_poses.append(block_pose)

        dist = np.linalg.norm(np.array(corner_poses[0][0])-np.array(corner_poses[1][0])) 
        n_parts = int(20 * dist / 0.4)

        # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
        objects, targets, matches = self.make_ropes(env, corners=(corner_poses[0][0], corner_poses[1][0]), n_parts=n_parts)
        self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1.,
                language_goal=self.lang_template.format(color1=target_colors[0], color2=target_colors[1]))

        # wait for the scene to settle down
        for i in range(600):
            p.stepSimulation()
```

###"
"Write the pybullet simulation code for the task ""build-car"" in a python code block.
###

"," 
 build-car: {'task-name': 'build-car', 'task-description': 'Construct a simple car structure using blocks and cylinders.', 'assets-used': ['block/block.urdf', 'ball/ball-template.urdf']}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildCar(Task):
    """"""Construct a simple car structure using blocks and cylinders.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""Construct a simple car structure using blocks and cylinders. "" \
                             ""Firstly, create the base of the car by positioning two red blocks side by side. "" \
                             ""Then, add the car body by stacking a blue block on top of the base. "" \
                             ""For the wheels, place a black cylinder on each side of the base blocks.""
        self.task_completed_desc = ""done building car.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        car_pose = ((0.5, 0.0, 0.0), (0,0,0,1))  # fixed pose
        base_length = 0.04
        self.add_corner_anchor_for_pose(env, car_pose)

        # Add base blocks. Use box template so that we can change its size.
        base_size = (0.02, 0.04, 0.02)
        base_block_urdf = ""box/box-template.urdf""
        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(car_pose, (base_length / 2,  base_length / 2, 0.001)), car_pose[1]),
                        (utils.apply(car_pose, (-base_length / 2,  base_length / 2, 0.001)), car_pose[1])]
        base_blocks = []
        
        for idx in range(2):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['red'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.04, 0.02, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [car_pose]

        wheel_length = 0.12
        anchor_wheel_poses = [(utils.apply(car_pose, ( wheel_length / 2,  wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, (-wheel_length / 2,  wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, ( wheel_length / 2, -wheel_length / 2, 0.001)), car_pose[1]),
                              (utils.apply(car_pose, (-wheel_length / 2, -wheel_length / 2, 0.001)), car_pose[1])]

        # Add wheels.
        wheel_size = (0.02, 0.02, 0.02)  # x, y, z dimensions for the asset size
        wheel_urdf = 'cylinder/cylinder-template.urdf'
        wheel_urdf = self.fill_template(wheel_urdf, {'DIM': wheel_size})

        wheels = []
        for idx in range(4):
            wheel_pose = self.get_random_pose(env, wheel_size)
            wheel_id = env.add_object(wheel_urdf, wheel_pose, color=utils.COLORS['black'])
            wheels.append(wheel_id)

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks,
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""Firstly, create the base of the car by positioning two red blocks side by side."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""Then, add the car body by stacking a blue block on top of the base."")

        # For the wheels, place a black cylinder on each side of the base blocks.
        self.add_goal(objs=wheels,
                      matches=np.ones((4, 4)),
                      targ_poses=anchor_wheel_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./3,
                      language_goal=""For the wheels, place a black cylinder on each side of the base blocks."")


```

###"
"Write the pybullet simulation code for the task ""manipulating-two-ropes"" in a python code block.
###

"," 
 manipulating-two-ropes: {'task-name': 'manipulating-two-ropes', 'task-description': 'rearrange the red and blue deformable ropes such that it connects the two endpoints of a 3-sided square of corresponding color.', 'assets-used': ['square/square-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class ManipulatingTwoRopes(Task):
    """"""rearrange the red and blue deformable ropes such that it connects the two endpoints of a 3-sided square of corresponding color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""rearrange the {color_name} rope such that it connects the two endpoints of a 3-sided square of corresponding color.""
        self.task_completed_desc = ""done manipulating two ropes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        n_parts = 20
        radius = 0.005
        length = 2 * radius * n_parts * np.sqrt(2)

        # Add 3-sided square for the red rope.
        color_list = ['red', 'blue']
        for color_name in color_list:
            square_size = (length, length, 0)
            square_pose = self.get_random_pose(env, square_size)
            square_template = 'square/square-template.urdf'

            # IMPORTANT: REPLACE THE TEMPLATE URDF  with `fill_template`
            replace = {'DIM': (length,), 'HALF': (np.float32(length) / 2 - 0.005,)}
            urdf = self.fill_template(square_template, replace)
            env.add_object(urdf, square_pose, 'fixed', color=utils.COLORS[color_name])

            # compute corners
            corner0 = (length / 2, length / 2, 0.001)
            corner1 = (-length / 2, length / 2, 0.001)
            corner_0 = utils.apply(square_pose, corner0)
            corner_1 = utils.apply(square_pose, corner1)

            # IMPORTANT: use `make_ropes` to add cable (series of articulated small blocks).
            objects, targets, matches = self.make_ropes(env, corners=(corner_0, corner_1), color_name=color_name)
            self.add_goal(objs=objects, matches=matches, targ_poses=targets, replace=False,
                    rotations=False, metric='pose', params=None, step_max_reward=1. / len(color_list),
                          language_goal=self.lang_template.format(color_name=color_name))

        print(f""len of languages: {len(self.lang_goals)} obj:{len(objects)}"")
        for i in range(480):
            p.stepSimulation()

```

###"
"Write the pybullet simulation code for the task ""insert-sphere-into-container"" in a python code block.
###

"," 
 insert-sphere-into-container: {'task-name': 'insert-sphere-into-container', 'task-description': 'Pick up a blue sphere and place it into an open container.', 'assets-used': ['sphere/sphere.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertSphereIntoContainer(Task):
    """"""Pick up a blue sphere and place it into an open container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""pick up a blue sphere and place it into an open container""
        self.task_completed_desc = ""done inserting sphere into container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        container_id = env.add_object(container_urdf, container_pose, 'fixed')

        # Add sphere.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_pose = self.get_random_pose(env, sphere_size)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS['blue'])

        # Goal: the blue sphere is in the container.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""insert-cylinder-in-container"" in a python code block.
###

"," 
 insert-cylinder-in-container: {'task-name': 'insert-cylinder-in-container', 'task-description': 'Pick up a blue cylindrical block and place it into an empty container.', 'assets-used': ['cylinder/cylinder-template.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertSphereIntoContainer(Task):
    """"""Pick up a blue sphere and place it into an open container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""pick up a blue sphere and place it into an open container""
        self.task_completed_desc = ""done inserting sphere into container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        container_id = env.add_object(container_urdf, container_pose, 'fixed')

        # Add sphere.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_pose = self.get_random_pose(env, sphere_size)
        sphere_urdf = 'sphere/sphere.urdf'
        sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS['blue'])

        # Goal: the blue sphere is in the container.
        self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""build-bridge"" in a python code block.
###

"," 
 build-bridge: {'task-name': 'build-bridge', 'task-description': 'Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.', 'assets-used': ['block/block.urdf', 'ball/ball-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"Write the pybullet simulation code for the task ""insert-ell-in-fixture"" in a python code block.
###

"," 
 insert-ell-in-fixture: {'task-name': 'insert-ell-in-fixture', 'task-description': 'Pick up an Ell shaped block and insert it into a fixture on the tabletop.', 'assets-used': ['insertion/ell.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"Write the pybullet simulation code for the task ""build-block-tower-on-pallet"" in a python code block.
###

"," 
 build-block-tower-on-pallet: {'task-name': 'build-block-tower-on-pallet', 'task-description': 'Pick up six blocks in two colors (three red and three blue) and stack them in alternating colors on the pallet. The tower should start with a red block at the bottom.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-tower"" in a python code block.
###

"," 
 color-coordinated-tower: {'task-name': 'color-coordinated-tower', 'task-description': 'Pick up blocks of five different colors (red, blue, green, yellow, and orange) and stack them on a pallet in the specific sequence. The bottom of the tower should start with a red block followed by a blue, green, yellow and finally an orange block at the top.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildBridge(Task):
    """"""Construct a bridge using two yellow blocks and three blue blocks.
    Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between.
    Then, place the blue block horizontally on top of the yellow blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a bridge using four yellow blocks and one long blue block""
        self.task_completed_desc = ""done building bridge.""

    def reset(self, env):
        super().reset(env)

        # Add yellow blocks.
        base_length = 0.04
        base_size = (base_length, base_length, base_length)
        base_block_urdf = ""box/box-template.urdf""
        bridge_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))  # fixed pose
        self.add_corner_anchor_for_pose(env, bridge_pose)

        base_block_urdf = self.fill_template(base_block_urdf,  {'DIM': base_size})
        anchor_base_poses = [(utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2,  0, 0.001)), bridge_pose[1]),
                        (utils.apply(bridge_pose, (- 3 * base_length / 2,  0, 0.041)), bridge_pose[1]),
                        (utils.apply(bridge_pose, ( 3 * base_length / 2, 0, 0.041)), bridge_pose[1])]
        base_blocks = []

        for idx in range(4):
            base_block_pose = self.get_random_pose(env, base_size)
            base_block_id = env.add_object(base_block_urdf, base_block_pose, color=utils.COLORS['yellow'])
            base_blocks.append(base_block_id)

        # Add car body block.
        body_size = (0.12, 0.04, 0.02)  # x, y, z dimensions for the asset size
        body_block_urdf = ""box/box-template.urdf""
        body_block_urdf = self.fill_template(body_block_urdf,  {'DIM': body_size})
        body_block_pose = self.get_random_pose(env, body_size)
        body_block_id = env.add_object(body_block_urdf, body_block_pose, color=utils.COLORS['blue'])
        anchor_body_poses = [bridge_pose]

        # Goal: Firstly, create the base of the car by positioning two red blocks side by side.
        self.add_goal(objs=base_blocks[:2],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        self.add_goal(objs=base_blocks[2:],
                      matches=np.ones((2, 2)),
                      targ_poses=anchor_base_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./2,
                      language_goal=""Place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between."")

        # Then, add the car body by stacking a blue block on top of the base.
        self.add_goal(objs=[body_block_id],
                      matches=np.ones((1, 1)),
                      targ_poses=anchor_body_poses,
                      replace=False,
                      rotations=True,
                      metric='pose',
                      params=None,
                      step_max_reward=1./4,
                      language_goal=""Then, place the blue block horizontally on top of the yellow blocks."")
```

###"
"Write the pybullet simulation code for the task ""stack-blocks-in-container"" in a python code block.
###

"," 
 stack-blocks-in-container: {'task-name': 'stack-blocks-in-container', 'task-description': 'Pick up five blocks of different colors (red, blue, green, yellow, and orange) and stack them in a container in a specific sequence. The bottom of the stack should start with a red block followed by a blue, green, yellow and finally an orange block at the top.', 'assets-used': ['block/block.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class StackBlocksInContainer(Task):
    """"""Pick up five blocks of different colors (red, blue, green, yellow, and orange) 
    and stack them in a container in a specific sequence. 
    The bottom of the stack should start with a red block followed by a blue, 
    green, yellow and finally an orange block at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""stack the blocks in the container in the following order: {order}""
        self.task_completed_desc = ""done stacking blocks in container.""
        self.order = ['red', 'blue', 'green', 'yellow', 'orange']
        self.colors = [utils.COLORS[color] for color in self.order]

    def reset(self, env):
        super().reset(env)

        # Add container.
        container_size = (0.15, 0.15, 0.15)  # x, y, z dimensions for the container size
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in self.colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Goal: each block is stacked in the container in the specified order.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                            language_goal=self.lang_template.format(order=', '.join(self.order)))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-block-tower"" in a python code block.
###

"," 
 color-coordinated-block-tower: {'task-name': 'color-coordinated-block-tower', 'task-description': 'On a tabletop, there are fifteen blocks of three different colors (five red, five blue, and five green). The task is to pick up these blocks and stack them onto three different stands on the table, creating three different towers. Each stand should have a tower of the same color blocks with five blocks each. The blocks in each tower should be stacked in a way that the block on top is slightly displaced in relation to the block underneath, creating a spiral-like effect. The challenge lies in the color-based sorting, precise placement for achieving the spiral effect and careful stacking of the blocks to avoid toppling.', 'assets-used': ['block/block.urdf', 'stacking/stand.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBlockTower(Task):
    """"""Stack four blocks on a pallet in the following order from bottom to top: 
    two blue blocks side by side, one red block centered on the blue blocks, 
    and one green block on top of the red block.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""stack four blocks on a pallet in the following order from bottom to top: two blue blocks side by side, one red block centered on the blue blocks, and one green block on top of the red block.""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.015)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['blue'], utils.COLORS['blue'], utils.COLORS['red'], utils.COLORS['green']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02), (0, 0, 0.06), (0, 0, 0.10)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: two blue blocks are placed side by side on the pallet.
        # Break the language prompt step-by-step
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                language_goal=""place two blue blocks side by side on the pallet"")

        # Goal: one red block is placed centered on the blue blocks.
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                language_goal=""place one red block centered on the blue blocks"")

        # Goal: one green block is placed on top of the red block.
        self.add_goal(objs=blocks[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                language_goal=""place one green block on top of the red block"")
```

###"
"Write the pybullet simulation code for the task ""color-structured-block-tower"" in a python code block.
###

"," 
 color-structured-block-tower: {'task-name': 'color-structured-block-tower', 'task-description': 'Construct a tower using six blocks: two red, two blue, and two green. The tower should be built in the order of a red block at the base, followed by a blue, then green, then red, blue and green at the top.', 'assets-used': ['block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorStructuredBlockTower(Task):
    """"""Construct a tower using six blocks: two red, two blue, and two green. 
    The tower should be built in the order of a red block at the base, 
    followed by a blue, then green, then red, blue and green at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""construct a tower using six blocks: two red, two blue, and two green. "" \
                             ""The tower should be built in the order of a red block at the base, "" \
                             ""followed by a blue, then green, then red, blue and green at the top.""
        self.task_completed_desc = ""done building color-structured block tower.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define block colors and sizes
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']] * 2
        block_size = (0.04, 0.04, 0.04)

        # Add blocks
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Define target poses for the blocks in the tower
        base_pose = self.get_random_pose(env, block_size)
        targ_poses = [base_pose]
        for i in range(1, 6):
            targ_poses.append((np.array(base_pose[0]) + np.array([0, 0, i * block_size[2]]), base_pose[1]))

        # Add goals
        for i in range(6):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/6, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""stack-color-coordinated-blocks"" in a python code block.
###

"," 
 stack-color-coordinated-blocks: {'task-name': 'stack-color-coordinated-blocks', 'task-description': 'Pick up six blocks of different colors (red, blue, green, yellow, orange, and purple) and stack them on a pallet in two separate stacks. The first stack should be red at the bottom, blue in the middle, and green at top. The second stack should be yellow at the bottom, orange in the middle, and purple at the top.', 'assets-used': ['box/box-template.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class StackColorCoordinatedBlocks(Task):
    """"""Pick up six blocks of different colors (red, blue, green, yellow, orange, and purple) 
    and stack them on a pallet in two separate stacks. The first stack should be red at the bottom, 
    blue in the middle, and green at top. The second stack should be yellow at the bottom, 
    orange in the middle, and purple at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the blocks on the pallet in two separate stacks. "" \
                             ""The first stack should be red at the bottom, blue in the middle, "" \
                             ""and green at top. The second stack should be yellow at the bottom, "" \
                             ""orange in the middle, and purple at the top.""
        self.task_completed_desc = ""done stacking color-coordinated blocks.""

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['purple']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'box/box-template.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02), 
                     (0, -0.05, 0.06), (0, 0, 0.06), (0, 0.05, 0.06)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the pallet in two separate stacks.
        # First stack: red at the bottom, blue in the middle, and green at top.
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)

        # Second stack: yellow at the bottom, orange in the middle, and purple at the top.
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""assemble-single-car"" in a python code block.
###

"," 
 assemble-single-car: {'task-name': 'assemble-single-car', 'task-description': 'Build a mini car using a large blue box as the body, a smaller red box on top as the roof, and two tiny green boxes on the sides as wheels.', 'assets-used': ['box/box-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class AssembleSingleCar(Task):
    """"""Assemble a mini car using a large blue box as the body, a smaller red box on top as the roof, and two tiny green boxes on the sides as wheels.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""build a mini car using a large blue box as the body, a smaller red box on top as the roof, and two tiny green boxes on the sides as wheels""
        self.task_completed_desc = ""done assembling the car.""

    def reset(self, env):
        super().reset(env)

        # Add car body (large blue box).
        body_size = (0.1, 0.05, 0.02)  # x, y, z dimensions
        body_pose = self.get_random_pose(env, body_size)
        body_urdf = 'box/box-template.urdf'
        body_color = utils.COLORS['blue']
        body_id = env.add_object(body_urdf, body_pose, color=body_color)

        # Add car roof (smaller red box).
        roof_size = (0.08, 0.04, 0.02)  # x, y, z dimensions
        roof_pose = self.get_random_pose(env, roof_size)
        roof_urdf = 'box/box-template.urdf'
        roof_color = utils.COLORS['red']
        roof_id = env.add_object(roof_urdf, roof_pose, color=roof_color)

        # Add car wheels (two tiny green boxes).
        wheel_size = (0.02, 0.02, 0.01)  # x, y, z dimensions
        wheel_urdf = 'box/box-template.urdf'
        wheel_color = utils.COLORS['green']
        wheel_ids = []
        
        for _ in range(2):
            wheel_pose = self.get_random_pose(env, wheel_size)
            wheel_id = env.add_object(wheel_urdf, wheel_pose, color=wheel_color)
            wheel_ids.append(wheel_id)

        # Goal: assemble the car by placing the roof on the body and the wheels on the sides.
        # The target poses are calculated based on the body pose.
        roof_targ_pose = (body_pose[0] + np.array([0, 0, body_size[2] + roof_size[2]/2]), body_pose[1])
        wheel_targ_poses = [(body_pose[0] + np.array([0, body_size[1]/2 + wheel_size[1]/2, -body_size[2]/2]), body_pose[1]),
                            (body_pose[0] + np.array([0, -body_size[1]/2 - wheel_size[1]/2, -body_size[2]/2]), body_pose[1])]

        # Add the goals.
        self.add_goal(objs=[roof_id], matches=np.ones((1, 1)), targ_poses=[roof_targ_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/3, language_goal=self.lang_template)

        self.add_goal(objs=wheel_ids, matches=np.ones((2, 2)), targ_poses=wheel_targ_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=2/3, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""sort-and-stack-clr-blocks"" in a python code block.
###

"," 
 sort-and-stack-clr-blocks: {'task-name': 'sort-and-stack-clr-blocks', 'task-description': 'Pick up four blocks of different colors (red, blue, green, yellow) and place them into separate corners of a pallet. After sorting, stack them in a specific sequence on top of the pallet. The bottom of the stack should start with a green block followed by a blue, then red, and finally a yellow block at the top.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortAndStackClrBlocks(Task):
    """"""Pick up four blocks of different colors (red, blue, green, yellow) and place them into separate corners of a pallet. After sorting, stack them in a specific sequence on top of the pallet. The bottom of the stack should start with a green block followed by a blue, then red, and finally a yellow block at the top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""sort and stack the blocks in the order of green, blue, red, and yellow""
        self.task_completed_desc = ""done sorting and stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0.05, 0.05, 0.02), (-0.05, 0.05, 0.02), (-0.05, -0.05, 0.02), (0.05, -0.05, 0.02)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are sorted into separate corners of the pallet.
        self.add_goal(objs=blocks, matches=np.eye(4), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=0.5, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)

        # Associate stacking locations for goals.
        stack_pos = [(0, 0, 0.02), (0, 0, 0.06), (0, 0, 0.10), (0, 0, 0.14)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in stack_pos]

        # Goal: blocks are stacked on top of the pallet in the order of green, blue, red, and yellow.
        self.add_goal(objs=blocks, matches=np.eye(4), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=0.5, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""create-pyramid-blocks-and-container"" in a python code block.
###

"," 
 create-pyramid-blocks-and-container: {'task-name': 'create-pyramid-blocks-and-container', 'task-description': 'Create a pyramid structure using six blocks of three different colors (two red, two green, and two blue) inside a container. The first layer of the pyramid should consist of the two green and one blue block. The second layer should be the two red blocks, and the last block which is the top of the pyramid should be the remaining blue block.', 'assets-used': ['container/container-template.urdf', 'block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CreatePyramidBlocksAndContainer(Task):
    """"""Create a pyramid structure using six blocks of three different colors (two red, two green, and two blue) inside a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Create a pyramid structure using six blocks of three different colors (two red, two green, and two blue) inside a container.""
        self.task_completed_desc = ""done creating pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.3, 0.3, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')
        self.add_corner_anchor_for_pose(env, container_pose)


        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['blue']]
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03), (0, 0.05, 0.03), (0, -0.025, 0.08), (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(container_pose, i), container_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, green, blue).
        self.add_goal(objs=blocks[2:5], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the green and blue blocks"",
                                                         row=""bottom""))

        # Goal: blocks are stacked in a pyramid (middle row: red, red).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template.format(blocks=""the red blocks"",
                                                         row=""middle""))

        # Goal: blocks are stacked in a pyramid (top row: blue).
        self.add_goal(objs=blocks[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(blocks=""the blue block"",
                                                         row=""top""))
```

###"
"Write the pybullet simulation code for the task ""Four-corner-pyramid-challenge"" in a python code block.
###

"," 
 Four-corner-pyramid-challenge: {'task-name': 'Four-corner-pyramid-challenge', 'task-description': ""A tabletop is partitioned into four different zones using the 'zone/zone.urdf' asset. In each zone, there are four blocks of different colors (red, blue, green, and yellow). The task is to construct a pyramid of blocks in each zone using the 'block/block.urdf' asset such that the sequence of blocks from bottom to top is red, blue, green, and yellow. The task is challenging because it requires precise stack control and color recognition."", 'assets-used': ['block/block.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class FourCornerPyramidChallenge(Task):
    """"""Construct a pyramid of blocks in each zone with a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""build a pyramid of blocks in each zone with the sequence red, blue, green, and yellow from bottom to top""
        self.task_completed_desc = ""done building pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            for _ in range(4):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=colors[i])
                blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_pose, i), zone_pose[1]) for i in place_pos for zone_pose in zone_poses]

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(4):
            self.add_goal(objs=blocks[i*4:(i+1)*4], matches=np.ones((4, 4)), targ_poses=targs[i*4:(i+1)*4], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*4,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""colorful-block-tower-on-cylinder-base"" in a python code block.
###

"," 
 colorful-block-tower-on-cylinder-base: {'task-name': 'colorful-block-tower-on-cylinder-base', 'task-description': 'Construct a tower using four blocks of different colors (red, blue, green, and yellow) on a placed cylindrical base at the corner of the tabletop. The sequence from bottom to top should be red, blue, green, and yellow.', 'assets-used': ['block/block.urdf', 'corner/corner-template.urdf', 'cylinder/cylinder-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorfulBlockTowerOnCylinderBase(Task):
    """"""Construct a tower using four blocks of different colors (red, blue, green, and yellow) on a placed cylindrical base at the corner of the tabletop. The sequence from bottom to top should be red, blue, green, and yellow.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""construct a tower using four blocks of different colors (red, blue, green, and yellow) on a placed cylindrical base at the corner of the tabletop. The sequence from bottom to top should be red, blue, green, and yellow.""
        self.task_completed_desc = ""done building the tower.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylindrical base.
        # x, y, z dimensions for the asset size
        base_size = (0.05, 0.05, 0.05)
        base_urdf = 'cylinder/cylinder-template.urdf'
        base_pose = self.get_random_pose(env, base_size)
        base_id = env.add_object(base_urdf, base_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'

        objs = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, 0, 0.05), (0, 0, 0.09), (0, 0, 0.13), (0, 0, 0.17)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the cylindrical base in the order red, blue, green, yellow from bottom to top.
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""construct-corner-blocks"" in a python code block.
###

"," 
 construct-corner-blocks: {'task-name': 'construct-corner-blocks', 'task-description': 'Create a corner structure using four blocks. Two red blocks form the base, one on each side of the corner, followed by a green block that is positioned on the red blocks at the corner junction, and finally a blue block on top of the green one. The overall structure forms a 3-D corner.', 'assets-used': ['block/block.urdf', 'corner/corner-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ConstructCornerBlocks(Task):
    """"""Create a corner structure using four blocks. Two red blocks form the base, one on each side of the corner, followed by a green block that is positioned on the red blocks at the corner junction, and finally a blue block on top of the green one. The overall structure forms a 3-D corner.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Create a corner structure using four blocks. Two red blocks form the base, one on each side of the corner, followed by a green block that is positioned on the red blocks at the corner junction, and finally a blue block on top of the green one. The overall structure forms a 3-D corner.""
        self.task_completed_desc = ""done constructing corner blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corner.
        corner_size = (0.15, 0.15, 0.05)
        corner_urdf = 'corner/corner-template.urdf'
        corner_pose = self.get_random_pose(env, corner_size)
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02), (0, 0, 0.06), (0, 0, 0.10)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a corner (bottom row: two red blocks).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a corner (middle row: one green block).
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*1,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a corner (top row: one blue block).
        self.add_goal(objs=blocks[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*1,
                          language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""corner-sort-cylinders"" in a python code block.
###

"," 
 corner-sort-cylinders: {'task-name': 'corner-sort-cylinders', 'task-description': 'Pick up cylinders of four different colors (red, blue, green, yellow) and place them into four corners accordingly marked on the tabletop. The corner is designed as a 2-block-size square where only one cylinder can fit. The task is challenging due to precise placement and the need for identifying the corners accurately.', 'assets-used': ['corner/corner-template.urdf', 'cylinder/cylinder-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CornerSortCylinders(Task):
    """"""Pick up cylinders of four different colors (red, blue, green, yellow) and place them into four corners accordingly marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} cylinder in the {color} corner""
        self.task_completed_desc = ""done sorting cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors
        colors = ['red', 'blue', 'green', 'yellow']

        # Add corners
        corner_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the asset size
        corner_template = 'corner/corner-template.urdf'
        corner_poses = []
        for color in colors:
            replace = {'DIM': corner_size, 'HALF': (corner_size[0] / 2, corner_size[1] / 2, corner_size[2] / 2), 'COLOR': utils.COLORS[color]}
            corner_urdf = self.fill_template(corner_template, replace)
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, 'fixed')
            corner_poses.append(corner_pose)

        # Add cylinders
        cylinder_size = (0.02, 0.02, 0.06)  # x, y, z dimensions for the asset size
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in colors:
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2), 'COLOR': utils.COLORS[color]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Add goals
        for i in range(len(cylinders)):
            self.add_goal(objs=[cylinders[i]], matches=np.int32([[1]]), targ_poses=[corner_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(cylinders),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""sorting-blocks-into-pallets"" in a python code block.
###

"," 
 sorting-blocks-into-pallets: {'task-name': 'sorting-blocks-into-pallets', 'task-description': 'Pick up blocks of four different colors (red, blue, green, yellow) and place them into four separate pallets of matching color. The pallets are placed in a row and the blocks are scattered randomly on the table.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortingBlocksIntoPallets(Task):
    """"""Pick up blocks of four different colors (red, blue, green, yellow) and place them into four separate pallets of matching color. The pallets are placed in a row and the blocks are scattered randomly on the table.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} block into the {color} pallet""
        self.task_completed_desc = ""done sorting blocks into pallets.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.12, 0.12, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        pallet_colors = ['red', 'blue', 'green', 'yellow']
        for color in pallet_colors:
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, 'fixed', color=utils.COLORS[color])
            pallet_poses.append(pallet_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        for color in pallet_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in a different pallet of matching color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[pallet_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), 
                language_goal=self.lang_template.format(color=pallet_colors[i]))
```

###"
"Write the pybullet simulation code for the task ""sort-and-assemble-block-castle"" in a python code block.
###

"," 
 sort-and-assemble-block-castle: {'task-name': 'sort-and-assemble-block-castle', 'task-description': 'On a tabletop, there are twelve blocks of three different colors (four red, four green, and four blue). The task involves sorting the blocks according to the color in three marked zones on the tabletop and subsequently constructing a castle in each zone. In each castle, the first layer should consist of the two blocks of the same color, followed by the second layer of one block and finally the last block on the top forming a castle-like structure. The challenge lies in the color-based sorting and careful assembly of the blocks to avoid toppling.', 'assets-used': ['block/block.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortAndAssembleBlockCastle(Task):
    """"""Sort blocks by color and assemble them into a castle-like structure.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 50
        self.lang_template = ""sort the blocks by color and assemble them into a castle""
        self.task_completed_desc = ""done sorting and assembling.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]
        blocks = []
        for color in block_colors:
            for _ in range(4):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=color)
                blocks.append(block_id)

        # Goal: each block is in a different zone based on color.
        for i in range(12):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 3)), targ_poses=zone_poses, replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/12)

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(3):
            zone_blocks = blocks[i*4:(i+1)*4]
            place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02),
                         (0, 0, 0.06), (0, 0, 0.10)]
            targs = [(utils.apply(zone_poses[i], pos), zone_poses[i][1]) for pos in place_pos]
            for j in range(4):
                self.add_goal(objs=[zone_blocks[j]], matches=np.ones((1, 1)), targ_poses=[targs[j]], replace=False,
                              rotations=True, metric='pose', params=None, step_max_reward=1/12, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""vertical-insertion-blocks"" in a python code block.
###

"," 
 vertical-insertion-blocks: {'task-name': 'vertical-insertion-blocks', 'task-description': 'The task involves picking up four color specific blocks (red, blue, green, and yellow) and inserting each block into four differently colored stands set upright on the tabletop. The block-colored with red needs to be inserted into the red-colored stand, and the same sequence is maintained for each colored blocks and stands. This task is challenging due to the requirement for precise insertion and the manipulation of vertical objects.', 'assets-used': ['stacking/block.urdf', 'stacking/stand.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class VerticalInsertionBlocks(Task):
    """"""Pick up four color specific blocks and insert each block into four differently colored stands set upright on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} stand""
        self.task_completed_desc = ""done inserting blocks into stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and stands
        colors = ['red', 'blue', 'green', 'yellow']

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.04, 0.04, 0.1)
        stand_urdf = 'stacking/stand.urdf'
        stands = []
        for color in colors:
            stand_pose = self.get_random_pose(env, stand_size)
            stand_id = env.add_object(stand_urdf, stand_pose, color=utils.COLORS[color], category='fixed')
            stands.append(stand_id)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is inserted into the stand of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(stands[i])], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-sphere-insertion"" in a python code block.
###

"," 
 color-coordinated-sphere-insertion: {'task-name': 'color-coordinated-sphere-insertion', 'task-description': 'There are four spheres and four boxes of different colors (red, blue, green, and yellow). Each sphere is inside a box, but not corresponding to the color of the box. The task is to pick up each sphere and place it in the box of the same color. The challenge lies in the precise placement and color matching.', 'assets-used': ['sphere/sphere.urdf', 'box/box-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedSphereInsertion(Task):
    """"""Insert each sphere into the bowl of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert each sphere into the bowl of the same color""
        self.task_completed_desc = ""done inserting spheres into bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = ['red', 'blue', 'green', 'yellow']
        color_values = [utils.COLORS[color] for color in colors]

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0.02)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for i in range(4):
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed', color=color_values[i])
            bowl_poses.append(bowl_pose)

        # Add spheres.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_template = 'sphere/sphere-template.urdf'
        spheres = []
        for i in range(4):
            sphere_pose = self.get_random_pose(env, sphere_size)
            replace = {'DIM': sphere_size, 'HALF': (sphere_size[0] / 2, sphere_size[1] / 2, sphere_size[2] / 2)}
            sphere_urdf = self.fill_template(sphere_template, replace)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=color_values[i])
            spheres.append(sphere_id)

        # Goal: each sphere is in a bowl of the same color.
        for i in range(4):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[bowl_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=f""insert the {colors[i]} sphere into the {colors[i]} bowl"")
```

###"
"Write the pybullet simulation code for the task ""block-pyramid-with-limited-space"" in a python code block.
###

"," 
 block-pyramid-with-limited-space: {'task-name': 'block-pyramid-with-limited-space', 'task-description': 'On a tabletop, there are twelve blocks of four different colors (three red, three green, three blue, three yellow). Three zones are defined, each with a triangle-shaped border that is marked. The task involves sorting the blocks according to the color into three zones on the tabletop and constructing a pyramid in each zone. In each pyramid, the base should contain two blocks of the same color, followed by the second layer of one block, thus forming a pyramid-like structure. However, the third yellow block should be placed in the center of the zones forming a smaller pyramid. The challenge lies in the color-based sorting, careful assembly of the blocks to avoid topple, and limited space in the zones which adds to the complexity.', 'assets-used': ['block/block.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BlockPyramidWithLimitedSpace(Task):
    """"""Sort blocks according to color into three zones on the tabletop and construct a pyramid in each zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 50
        self.lang_template = ""sort the blocks according to color into three zones and construct a pyramid in each zone""
        self.task_completed_desc = ""done sorting and constructing pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=color)
                blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_pose, i), zone_pose[1]) for zone_pose in zone_poses for i in place_pos]

        # Goal: blocks are sorted and stacked in a pyramid in each zone.
        for i in range(3):
            self.add_goal(objs=blocks[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                    language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""build-cylinder-structure"" in a python code block.
###

"," 
 build-cylinder-structure: {'task-name': 'build-cylinder-structure', 'task-description': ""Using four colored cylinders (red, blue, green, yellow), construct a structure atop a square base. The red and blue cylinders should be sealed by the square base side by side, while the green cylinder should be on top of the blue one, and the yellow one on top of the red. The final look should resemble the letter 'H'."", 'assets-used': ['cylinder/cylinder-template.urdf', 'square/square-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BuildCylinderStructure(Task):
    """"""Construct a structure using four colored cylinders (red, blue, green, yellow) on a square base.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 5
        self.lang_template = ""construct a structure using four colored cylinders on a square base""
        self.task_completed_desc = ""done building the cylinder structure.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add square base.
        # x, y, z dimensions for the asset size
        base_size = (0.15, 0.15, 0.005)
        base_urdf = 'square/square-template.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Cylinder colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']
        ]

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.08)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        objs = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            objs.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.04), (0, 0.05, 0.04),
                     (0, 0.05, 0.12), (0, -0.05, 0.12)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: red and blue cylinders are placed side by side on the base.
        self.add_goal(objs=objs[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                language_goal=""place the red and blue cylinders side by side on the base"")

        # Goal: green cylinder is placed on top of the blue cylinder.
        self.add_goal(objs=[objs[2]], matches=np.ones((1, 1)), targ_poses=[targs[2]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                language_goal=""place the green cylinder on top of the blue cylinder"")

        # Goal: yellow cylinder is placed on top of the red cylinder.
        self.add_goal(objs=[objs[3]], matches=np.ones((1, 1)), targ_poses=[targs[3]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                language_goal=""place the yellow cylinder on top of the red cylinder"")
```

###"
"Write the pybullet simulation code for the task ""insert-blocks-lineup"" in a python code block.
###

"," 
 insert-blocks-lineup: {'task-name': 'insert-blocks-lineup', 'task-description': 'On the tabletop, there are four different color blocks (red, blue, green, and yellow), and four fixtures in corresponding colors. The task is to pick up each block and insert it into the corresponding color fixture. However, the fixtures are arranged in a straight line, with a line of small blocks serving as barrier between the fixtures and the colored blocks initially scattered on the table, providing a challenge in precise navigation and placement.', 'assets-used': ['block/block.urdf', 'insertion/fixture.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertBlocksLineup(Task):
    """"""Pick up four different color blocks and insert them into the corresponding color fixtures.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and fixtures
        colors = ['red', 'blue', 'green', 'yellow']

        # Add fixtures.
        fixture_size = (0.04, 0.04, 0.04)
        fixture_urdf = 'insertion/fixture.urdf'
        fixture_poses = []
        for i in range(4):
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[colors[i]], category='fixed')
            fixture_poses.append((fixture_pose, fixture_id))

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[colors[i]])
            blocks.append(block_id)

        # Add small blocks as barriers.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'block/small.urdf'
        for _ in range(10):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is in the corresponding color fixture.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[fixture_poses[i][0]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-specific-container-fill"" in a python code block.
###

"," 
 color-specific-container-fill: {'task-name': 'color-specific-container-fill', 'task-description': 'Arrange four colored blocks (red, blue, green, and yellow) around a pallet. Then, pick up these blocks and place them inside a container marked in the same color. The task requires precise placement, color matching, and an understanding of spatial structures.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSpecificContainerFill(Task):
    """"""Arrange four colored blocks (red, blue, green, and yellow) around a pallet. 
    Then, pick up these blocks and place them inside a container marked in the same color. 
    The task requires precise placement, color matching, and an understanding of spatial structures.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} block in the {color} container""
        self.task_completed_desc = ""done arranging blocks in containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define block and container colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add blocks and containers.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        container_size = (0.12, 0.12, 0.05)
        container_template = 'container/container-template.urdf'
        blocks = []
        containers = []
        for color in colors:
            # Add block.
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

            # Add container.
            container_pose = self.get_random_pose(env, container_size)
            replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
            container_urdf = self.fill_template(container_template, replace)
            container_id = env.add_object(container_urdf, container_pose, 'fixed', color=utils.COLORS[color])
            containers.append(container_id)

        # Goal: each block is in a container of the same color.
        for i in range(len(colors)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(containers[i])], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""multicolor-block-bridge"" in a python code block.
###

"," 
 multicolor-block-bridge: {'task-name': 'multicolor-block-bridge', 'task-description': 'Build a bridge by stacking three red, three blue, and three green blocks on a pallet. Arrange in a sequence from left to right: red, blue, and green. Then, place three cylinders of corresponding colors on top of the stacked blocks, forming a bridge. The cylinders should roll from the top block to the pallet, creating a challenge of precision and control.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'cylinder/cylinder-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MulticolorBlockBridge(Task):
    """"""Build a bridge by stacking three red, three blue, and three green blocks on a pallet. 
    Arrange in a sequence from left to right: red, blue, and green. 
    Then, place three cylinders of corresponding colors on top of the stacked blocks, forming a bridge. 
    The cylinders should roll from the top block to the pallet, creating a challenge of precision and control.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Build a bridge by stacking three red, three blue, and three green blocks on a pallet. Arrange in a sequence from left to right: red, blue, and green. Then, place three cylinders of corresponding colors on top of the stacked blocks, forming a bridge.""
        self.task_completed_desc = ""done building the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']]
        blocks = []
        for i in range(9):  # 3 blocks of each color
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i // 3])
            blocks.append(block_id)

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(3):  # 1 cylinder of each color
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2)}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=block_colors[i])
            cylinders.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03), (0, 0.05, 0.03)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked on the pallet in the order red, blue, green.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i // 3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 9, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: cylinders are placed on top of the stacked blocks.
        for i in range(3):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2], 
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""pyramid-blocks-assemble"" in a python code block.
###

"," 
 pyramid-blocks-assemble: {'task-name': 'pyramid-blocks-assemble', 'task-description': 'Construct a pyramid using nine blocks in a specific color order on a pallet. The bottom layer should contain five blocks: red, blue, green, yellow, and orange (in that order from left to right). The middle layer should consist of three blocks: yellow, red, and blue (from left to right). The top layer should contain a single green block. The pyramid requires careful placement and color matching.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PyramidBlocksAssemble(Task):
    """"""Construct a pyramid using nine blocks in a specific color order on a pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""construct a pyramid using nine blocks in a specific color order on a pallet""
        self.task_completed_desc = ""done constructing pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.35, 0.35, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for _ in range(9):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [
            (-0.1, -0.1, 0.02), (0, -0.1, 0.02), (0.1, -0.1, 0.02), (-0.1, 0, 0.02), (0.1, 0, 0.02),
            (-0.05, 0.05, 0.06), (0.05, 0.05, 0.06), (0, 0.1, 0.06),
            (0, 0.05, 0.1)
        ]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid in a specific color order.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 9, 
                          language_goal=self.lang_template.format(blocks=""the blocks"",
                                                             row=""row""))
```

###"
"Write the pybullet simulation code for the task ""place-ball-in-elevated-bowl"" in a python code block.
###

"," 
 place-ball-in-elevated-bowl: {'task-name': 'place-ball-in-elevated-bowl', 'task-description': 'The primary objective of the task is to pick up a red ball and carefully place it into a bowl, which is positioned on a raised platform that is surrounded by small blocks. The challenge lies in precise navigation, maintaining a hold of the ball, and avoiding the surrounding blocks.', 'assets-used': ['ball/ball-template.urdf', 'bowl/bowl.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class PlaceBallInElevatedBowl(Task):
    """"""Pick up a red ball and carefully place it into a bowl, which is positioned on a raised platform that is surrounded by small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the red ball in the elevated bowl""
        self.task_completed_desc = ""done placing ball in bowl.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add elevated platform.
        platform_size = (0.3, 0.3, 0.05)

        # Add bowl on the platform.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_pose[0][2] += platform_size[2]  # place the bowl on top of the platform
        bowl_id = env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Add red ball.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        ball_pose = self.get_random_pose(env, ball_size)
        ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS['red'])

        # Add small blocks around the platform.
        block_size = (0.02, 0.02, 0.02)
        block_urdf = 'block/small.urdf'
        for _ in range(5):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: the red ball is in the bowl.
        self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[bowl_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""align-balls-in-colored-zones"" in a python code block.
###

"," 
 align-balls-in-colored-zones: {'task-name': 'align-balls-in-colored-zones', 'task-description': 'There are six balls of different colors (red, blue, green, yellow, orange, and purple) and six zones correspondingly colored. The task is to pick up each ball and place it in the zone of the same color, arranging the balls in a straight line. The challenge lies in the precise placement and color matching.', 'assets-used': ['ball/ball-template.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class AlignBallsInColoredZones(Task):
    """"""Align balls of different colors in correspondingly colored zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} zone""
        self.task_completed_desc = ""done aligning balls in colored zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for balls and zones
        colors = ['red', 'blue', 'green', 'yellow', 'orange', 'purple']
        color_names = ['Red', 'Blue', 'Green', 'Yellow', 'Orange', 'Purple']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(6):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for i in range(6):
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'DIM': ball_size, 'HALF': (ball_size[0] / 2, ball_size[1] / 2, ball_size[2] / 2), 'COLOR': colors[i]}
            ball_urdf = self.fill_template(ball_urdf, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            balls.append(ball_id)

        # Goal: each ball is in a different colored zone.
        for i in range(6):
            self.add_goal(objs=[balls[i]], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6,
                language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-cylinder-tower"" in a python code block.
###

"," 
 color-coordinated-cylinder-tower: {'task-name': 'color-coordinated-cylinder-tower', 'task-description': 'Stack cylinders of four different colors (red, blue, green, yellow) on top of each other on a square stand in a specific sequence. The bottom of the stack should start with a blue cylinder, follow by a green cylinder, then a red one, and finally a yellow cylinder at the top. Each cylinder has to be aligned correctly to avoid falling.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedCylinderTower(Task):
    """"""Stack cylinders of four different colors (red, blue, green, yellow) on top of each other on a square stand in a specific sequence. The bottom of the stack should start with a blue cylinder, follow by a green cylinder, then a red one, and finally a yellow cylinder at the top. Each cylinder has to be aligned correctly to avoid falling.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""Stack cylinders of four different colors (red, blue, green, yellow) on top of each other on a square stand in a specific sequence. The bottom of the stack should start with a blue cylinder, follow by a green cylinder, then a red one, and finally a yellow cylinder at the top.""
        self.task_completed_desc = ""done stacking cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Cylinder colors.
        colors = [utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['red'], utils.COLORS['yellow']]

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        objs = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            objs.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, 0, 0.03), (0, 0, 0.08), (0, 0, 0.13), (0, 0, 0.18)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: cylinders are stacked in a tower (bottom to top: blue, green, red, yellow).
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""symmetric-block-bridge-construction"" in a python code block.
###

"," 
 symmetric-block-bridge-construction: {'task-name': 'symmetric-block-bridge-construction', 'task-description': 'Create a symmetrical bridge-shaped structure on a stand using eight blocks of two different colors (four red and four blue). Start by placing two red blocks side by side at the center of the stand to form the base of the bridge. Then, take a blue block and place it on top of the red blocks, followed by another red block on top of the blue one, and this pattern continues till you exhaust all the blocks. The final structure should be a bridge with alternating colors (red, blue, red, blue). The challenge lies in ensuring symmetry and balancing the blocks without making them fall.', 'assets-used': ['stacking/stand.urdf', 'block/block-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SymmetricBlockBridgeConstruction(Task):
    """"""Create a symmetrical bridge-shaped structure on a stand using eight blocks of two different colors (four red and four blue).""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""create a symmetrical bridge-shaped structure on a stand using eight blocks of two different colors (four red and four blue)""
        self.task_completed_desc = ""done building the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue']]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(8):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i%2])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13),
                     (0, -0.025, 0.18), (0, 0.025, 0.18)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a bridge (bottom row: red, red).
        self.add_goal(objs=objs[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*2,
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (second row: blue).
        self.add_goal(objs=objs[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (third row: red).
        self.add_goal(objs=objs[3:4], matches=np.ones((1, 1)), targ_poses=targs[3:4], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (fourth row: blue).
        self.add_goal(objs=objs[4:5], matches=np.ones((1, 1)), targ_poses=targs[4:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (fifth row: red).
        self.add_goal(objs=objs[5:6], matches=np.ones((1, 1)), targ_poses=targs[5:6], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (sixth row: blue).
        self.add_goal(objs=objs[6:7], matches=np.ones((1, 1)), targ_poses=targs[6:7], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (top row: red, red).
        self.add_goal(objs=objs[7:], matches=np.ones((1, 1)), targ_poses=targs[7:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""sphere-align-stand"" in a python code block.
###

"," 
 sphere-align-stand: {'task-name': 'sphere-align-stand', 'task-description': 'On a table there are five differently colored stands and five spheres. The task involves picking up each sphere and placing it on the stand of the matching color. The task is challenging due to the precision required in picking up and placing the spheres, and the color coordination.', 'assets-used': ['stacking/stand.urdf', 'sphere/sphere.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SphereAlignStand(Task):
    """"""Pick up each sphere and place it on the stand of the matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 5
        self.lang_template = ""place the {color} sphere on the {color} stand""
        self.task_completed_desc = ""done aligning spheres with stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the spheres and stands
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = ['red', 'green', 'blue', 'yellow', 'purple']

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.05, 0.05, 0.05)
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i in range(5):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, 'fixed', color=utils.COLORS[colors[i]])
            stand_poses.append(stand_pose)

        # Add spheres.
        # x, y, z dimensions for the asset size
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for i in range(5):
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[colors[i]])
            spheres.append(sphere_id)

        # Goal: each sphere is on the stand of the matching color.
        for i in range(5):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[stand_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""construct-colorful-arch"" in a python code block.
###

"," 
 construct-colorful-arch: {'task-name': 'construct-colorful-arch', 'task-description': 'Construct an arch using six blocks: three red, and three blue. Place two red blocks on the tabletop parallel to each other, then place a blue block on top of the red blocks to form a basic arch. Repeat the process by placing a red block on each side of the base arch and bridge them with the last blue block. Finally, place the last two red blocks on top of the second layer of the red blocks, on either side. The overall structure forms a colorful 3D arch.', 'assets-used': ['block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ConstructColorfulArch(Task):
    """"""Construct an arch using six blocks: three red, and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Construct an arch using six blocks: three red, and three blue.""
        self.task_completed_desc = ""done constructing colorful arch.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        colors = [utils.COLORS['red'], utils.COLORS['blue']]
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            color = colors[i // 3]  # First three blocks are red, last three are blue
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02),  # Base layer
                     (0, 0, 0.06),  # Second layer
                     (0, -0.05, 0.10), (0, 0.05, 0.10),  # Third layer
                     (0, 0, 0.14)]  # Top layer
        targs = [(utils.apply(block_pose, i), block_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in an arch (bottom layer: red, red).
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=""Place two red blocks on the tabletop parallel to each other"")

        # Goal: blocks are stacked in an arch (second layer: blue).
        self.add_goal(objs=blocks[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=""Place a blue block on top of the red blocks to form a basic arch"")

        # Goal: blocks are stacked in an arch (third layer: red, red).
        self.add_goal(objs=blocks[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2,
                          language_goal=""Place a red block on each side of the base arch"")

        # Goal: blocks are stacked in an arch (top layer: blue).
        self.add_goal(objs=blocks[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2],
                          language_goal=""Bridge them with the last blue block"")
```

###"
"Write the pybullet simulation code for the task ""color-sorted-container-stack"" in a python code block.
###

"," 
 color-sorted-container-stack: {'task-name': 'color-sorted-container-stack', 'task-description': 'The challenge is to stack four differently colored blocks (red, blue, green, yellow) inside a container. These blocks are initially placed inside two separate bowls. The red and blue blocks are in one bowl, the yellow and green blocks are in another. The robot has to pick up the blocks from the two bowls and stack them inside the container in the specific order: red, blue, green, then yellow.', 'assets-used': ['bowl/bowl.urdf', 'container/container-template.urdf', 'block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSortedContainerStack(Task):
    """"""Stack four differently colored blocks (red, blue, green, yellow) inside a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the blocks in the container in the order: red, blue, green, then yellow""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        # x, y, z dimensions for the asset size
        container_size = (0.15, 0.15, 0.15)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        for i in range(2):
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Goal: each block is stacked in the container in the order: red, blue, green, yellow.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4,
                language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""align-spheres-in-colored-zones"" in a python code block.
###

"," 
 align-spheres-in-colored-zones: {'task-name': 'align-spheres-in-colored-zones', 'task-description': 'There are four spheres of different colors (red, blue, green, yellow) positioned randomly on the table along with four zones marked with matching colors. The task is to pick up each sphere and place it into the matching colored zone with precise placement.', 'assets-used': ['sphere/sphere-template.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignSpheresInColoredZones(Task):
    """"""Align spheres of different colors in the matching colored zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere in the {color} zone""
        self.task_completed_desc = ""done aligning spheres in colored zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors
        colors = ['red', 'blue', 'green', 'yellow']
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for color in colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add spheres.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere-template.urdf'
        spheres = []
        for i, color in enumerate(colors):
            sphere_pose = self.get_random_pose(env, sphere_size)
            replace = {'DIM': sphere_size, 'HALF': (sphere_size[0] / 2, sphere_size[1] / 2, sphere_size[2] / 2)}
            sphere_urdf = self.fill_template(sphere_urdf, replace)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[color])
            spheres.append(sphere_id)

            # Add goal
            self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""sort-insert-color-coordinated-blocks"" in a python code block.
###

"," 
 sort-insert-color-coordinated-blocks: {'task-name': 'sort-insert-color-coordinated-blocks', 'task-description': 'There are six blocks of three different colors (two red, two blue, and two green), two red containers, two blue containers, and two green containers scattered on the table. The task is to sort the blocks by their colors and place (insert) them into the containers of the matching color. Two blocks of the same color should go into two different containers of the same color. The challenge lies in the color-based sorting and insertion of the blocks into the containers.', 'assets-used': ['block/block.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class SortInsertColorCoordinatedBlocks(Task):
    """"""Sort blocks by their colors and place them into the containers of the matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""sort the blocks by their colors and place them into the containers of the matching color""
        self.task_completed_desc = ""done sorting and inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_size = (0.1, 0.1, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_urdf = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, replace)
        container_colors = ['red', 'blue', 'green']
        container_poses = []
        for color in container_colors:
            container_pose = self.get_random_pose(env, container_size)
            env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            container_poses.append(container_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = ['red', 'red', 'blue', 'blue', 'green', 'green']
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in a container of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[container_poses[i//2]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""color-ordered-insertion"" in a python code block.
###

"," 
 color-ordered-insertion: {'task-name': 'color-ordered-insertion', 'task-description': 'There are four differently-colored ell objects (red, blue, green, yellow) and a corresponding set of color-coded fixtures. The task involves picking up each ell object and inserting it into the matching color fixture in a specific order: from left to right, insert red, blue, green, and finally yellow. The challenge lies in the precise manipulation of the ell objects and the color-coordination required. The fixtures are arranged in a straight line, and can only be approached from one direction, demanding careful navigation.', 'assets-used': ['insertion/ell.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedInsertion(Task):
    """"""Insert differently-colored ell objects into the matching color fixture in a specific order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} ell into the matching fixture""
        self.task_completed_desc = ""done inserting ells.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']
        color_order = {color: i for i, color in enumerate(colors)}

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0.02)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add ell objects.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell is inserted into the matching color fixture in the correct order.
        for i, ell in enumerate(ells):
            self.add_goal(objs=[ell], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(ells),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-insertion"" in a python code block.
###

"," 
 color-coordinated-insertion: {'task-name': 'color-coordinated-insertion', 'task-description': 'There are three insertion fixtures and three ell shaped blocks of different colors (red, blue, green) on the table top. The task is to pick up the ell shaped blocks and insert each one of them into the fixture of the same color. However, the ell blocks should be inserted in a specific sequence - red first, then blue, and finally green. This task is challenging due to the precision required for insertion and the need for color coordination and sequencing.', 'assets-used': ['insertion/ell.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedInsertion(Task):
    """"""Insert each block into the fixture of the same color""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert each block into the fixture of the same color""
        self.task_completed_desc = ""done with color-coordinated-insertion.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.35, 0.35, 0.01)
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add fixtures and blocks.
        colors = ['red', 'blue', 'green', 'yellow']
        fixtures = []
        blocks = []
        fixture_size = (0.05, 0.05, 0.05)
        block_size = (0.04, 0.04, 0.04)
        fixture_urdf = 'insertion/fixture.urdf'
        block_urdf = 'block/block.urdf'
        for color in colors:
            # Add fixture.
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

            # Add block.
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                          language_goal=self.lang_template)

        # Goal: each fixture is on the pallet.
        for i in range(len(fixtures)):
            self.add_goal(objs=[fixtures[i]], matches=np.ones((1, 1)), targ_poses=[pallet_pose], replace=False,
                          rotations=True, metric='zone', params=[(pallet_pose, pallet_size)], step_max_reward=1 / len(fixtures),
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""cylinder-stand-alignment"" in a python code block.
###

"," 
 cylinder-stand-alignment: {'task-name': 'cylinder-stand-alignment', 'task-description': 'Arrange four colored cylinders (red, blue, green, yellow) in order of their colors on four stands of matching color. However, the stands are placed in a random order on the table, which increases the complexity of the task as it requires careful planning and color matching.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderStandAlignment(Task):
    """"""Arrange four colored cylinders (red, blue, green, yellow) in order of their colors on four stands of matching color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Arrange the {color} cylinder on the {color} stand""
        self.task_completed_desc = ""done arranging cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2),
                       'COLOR': colors[i]}
            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(cylinder_urdf, replace)
            cylinder_id = env.add_object(urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Add stands.
        # x, y, z dimensions for the asset size
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stands = []
        for i in range(4):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, color=colors[i], category='fixed')
            stands.append(stand_pose)

        # Goal: each cylinder is on a stand of the same color.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[stands[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 4,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""color-sorted-block-race"" in a python code block.
###

"," 
 color-sorted-block-race: {'task-name': 'color-sorted-block-race', 'task-description': 'On one end of a tabletop, there are six blocks in two colors (three red and three blue). On the other end of the tabletop, two sets of three small marked zones are arranged in a straight line, one set for blue and one set for red. The task involves picking up one block at a time and placing it in the corresponding colored zone in a sequence from the bottom end zone to the top end zone. The blocks must be placed following the rule: the three colored blocks must be transported consecutively, e.g., first place all three blue blocks and then place all three red blocks. The challenge lies in careful transportation and placement of the blocks and follows the specific rule.', 'assets-used': ['block/block.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSortedBlockRace(Task):
    """"""Pick up blocks of two colors and place them in corresponding colored zones in a sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the blocks in the corresponding colored zones in sequence""
        self.task_completed_desc = ""done placing blocks in zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_colors = ['blue', 'red']
        zone_poses = []
        for color in zone_colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = ['blue', 'red']
        blocks = []
        for color in block_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Goal: each block is in the corresponding colored zone.
        for i, block in enumerate(blocks):
            self.add_goal(objs=[block], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""multi-level-block-construction"" in a python code block.
###

"," 
 multi-level-block-construction: {'task-name': 'multi-level-block-construction', 'task-description': 'Construct a two-level structure on a pallet using four blocks: two red and two blue. The lower level should be a rectangle created by placing the red blocks side by side. The upper level is made up by placing the blue blocks placed on top of the red blocks creating a line aligned perpendicular to the red blocks. The challenge lies in the precise placement of blocks, maintaining balance of the structure, and correct color arrangement.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MultiLevelBlockConstruction(Task):
    """"""Construct a two-level structure on a pallet using four blocks: two red and two blue. 
    The lower level should be a rectangle created by placing the red blocks side by side. 
    The upper level is made up by placing the blue blocks placed on top of the red blocks 
    creating a line aligned perpendicular to the red blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""construct a two-level structure on a pallet using four blocks: two red and two blue""
        self.task_completed_desc = ""done constructing multi-level block structure.""

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.015)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['blue']]
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.02, 0.02), (0, 0.02, 0.02),
                     (0, -0.02, 0.06), (0, 0.02, 0.06)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: red blocks are placed side by side on the pallet.
        self.add_goal(objs=blocks[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2, language_goal=self.lang_template)

        # Goal: blue blocks are stacked on top of the red blocks.
        self.add_goal(objs=blocks[2:], matches=np.ones((2, 2)), targ_poses=targs[2:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""color-blocks-in-cylinder-maze"" in a python code block.
###

"," 
 color-blocks-in-cylinder-maze: {'task-name': 'color-blocks-in-cylinder-maze', 'task-description': 'Pick up five differently colored blocks (red, blue, yellow, green, and orange) that are scattered randomly on the table top. Arrange three cylindrical containers in a row to create a maze-like structure. Place the red, yellow, and blue block into the first, second, and third cylinder from left respectively. Then, stack the green and orange block on top of any container, followed by placing the same color palette on the respective block.', 'assets-used': ['block/block.urdf', 'cylinder/cylinder-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorBlocksInCylinderMaze(Task):
    """"""Pick up five differently colored blocks (red, blue, yellow, green, and orange) that are scattered randomly on the table top. Arrange three cylindrical containers in a row to create a maze-like structure. Place the red, yellow, and blue block into the first, second, and third cylinder from left respectively. Then, stack the green and orange block on top of any container, followed by placing the same color palette on the respective block.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""arrange the blocks in the cylinders and stack the green and orange blocks""
        self.task_completed_desc = ""done arranging blocks in cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylinders.
        cylinder_size = (0.05, 0.05, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for _ in range(3):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            env.add_object(cylinder_urdf, cylinder_pose, 'fixed')
            cylinder_poses.append(cylinder_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['yellow'], utils.COLORS['green'], utils.COLORS['orange']]
        blocks = []
        for i in range(5):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[i])
            blocks.append(block_id)

        # Goal: red, yellow, and blue blocks are in the first, second, and third cylinder respectively.
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=cylinder_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=self.lang_template)

        # Goal: green and orange blocks are stacked on top of any cylinder.
        self.add_goal(objs=blocks[3:], matches=np.ones((2, 3)), targ_poses=cylinder_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""create-pyramid-with-color-coded-ells"" in a python code block.
###

"," 
 create-pyramid-with-color-coded-ells: {'task-name': 'create-pyramid-with-color-coded-ells', 'task-description': ""There are four insertion ell-shaped objects ('insertion/ell.urdf') of different colors (red, blue, yellow, and green) placed randomly on the tabletop. The task is to pick up each of these objects and stack them onto a fixed-size pallet in the shape of a pyramid. The order of the pyramid from bottom to top should be red, blue, yellow, and green."", 'assets-used': ['insertion/ell.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class CreatePyramidWithColorCodedElls(Task):
    """"""Pick up ell-shaped objects of different colors and stack them onto a pallet in the shape of a pyramid.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the {color} ell on the pyramid""
        self.task_completed_desc = ""done stacking ell pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.01)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Ell colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], 
            utils.COLORS['yellow'], utils.COLORS['green']
        ]
        color_names = ['red', 'blue', 'yellow', 'green']

        # Add Ells.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        objs = []
        for i in range(4):
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=colors[i])
            objs.append(ell_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0, 0.08)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: Ells are stacked in a pyramid (bottom row: red, middle row: blue, top row: yellow, green).
        for i in range(4):
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""move-piles-along-line"" in a python code block.
###

"," 
 move-piles-along-line: {'task-name': 'move-piles-along-line', 'task-description': 'Move three piles of small blocks, each pile a different color (red, blue, green), along three matching colored lines to three separate zones of the same color using a spatula.', 'assets-used': ['block/small.urdf', 'zone/zone.urdf', 'line/line-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class MovePilesAlongLine(Task):
    """"""Move three piles of small blocks, each pile a different color (red, blue, green), 
    along three matching colored lines to three separate zones of the same color using a spatula.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the piles of blocks along the lines to the matching colored zones""
        self.task_completed_desc = ""done moving piles.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add three colored lines.
        line_template = 'line/line-template.urdf'
        line_colors = ['red', 'blue', 'green']
        line_poses = []
        for color in line_colors:
            line_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            line_pose = self.get_random_pose(env, line_size)
            replace = {'DIM': line_size, 'HALF': (line_size[0] / 2, line_size[1] / 2, line_size[2] / 2), 'COLOR': color}
            line_urdf = self.fill_template(line_template, replace)
            env.add_object(line_urdf, line_pose, 'fixed')
            line_poses.append(line_pose)

        # Add three colored zones.
        zone_template = 'zone/zone.urdf'
        zone_poses = []
        for color in line_colors:
            zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            zone_pose = self.get_random_pose(env, zone_size)
            replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2), 'COLOR': color}
            zone_urdf = self.fill_template(zone_template, replace)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add three piles of small blocks.
        block_template = 'block/small.urdf'
        block_colors = ['red', 'blue', 'green']
        block_ids = []
        for color in block_colors:
            block_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
            block_pose = self.get_random_pose(env, block_size)
            replace = {'DIM': block_size, 'HALF': (block_size[0] / 2, block_size[1] / 2, block_size[2] / 2), 'COLOR': color}
            block_urdf = self.fill_template(block_template, replace)
            block_id = env.add_object(block_urdf, block_pose)
            block_ids.append(block_id)

        # Add goals.
        for i in range(3):
            self.add_goal(objs=[block_ids[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1/3,
                          language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""color-ordered-blocks-on-pallet"" in a python code block.
###

"," 
 color-ordered-blocks-on-pallet: {'task-name': 'color-ordered-blocks-on-pallet', 'task-description': 'On a table there are six different colored blocks (red, blue, green, yellow, orange, and purple), a pallet, and a small corner structure. These colored blocks are arranged randomly within the small corner structure. The task involves picking up each colored block and placing it onto the pallet in specific color sequence: red, blue, green, yellow, orange, and finally purple.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'corner/corner-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedBlocksOnPallet(Task):
    """"""Pick up each colored block and place it onto the pallet in specific color sequence: red, blue, green, yellow, orange, and finally purple.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the colored blocks onto the pallet in the following order: red, blue, green, yellow, orange, and purple""
        self.task_completed_desc = ""done placing blocks on the pallet.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['purple']
        ]

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are placed on the pallet in the order of red, blue, green, yellow, orange, purple.
        for i in range(6):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2], language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""color-ordered-container-arrangement"" in a python code block.
###

"," 
 color-ordered-container-arrangement: {'task-name': 'color-ordered-container-arrangement', 'task-description': 'On the tabletop, there are six containers and six blocks of different colors (red, blue, green, yellow, orange, purple). The task is to pick up each block and place it into a container of the same color, then arrange the containers in a line in the following color order: red, blue, green, yellow, orange, and purple.', 'assets-used': ['block/block.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedContainerArrangement(Task):
    """"""Arrange six containers with blocks of matching colors in a specific color order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""arrange the containers in the color order: red, blue, green, yellow, orange, and purple""
        self.task_completed_desc = ""done arranging containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define color order
        color_order = ['red', 'blue', 'green', 'yellow', 'orange', 'purple']

        # Add containers and blocks
        container_template = 'container/container-template.urdf'
        container_size = (0.12, 0.12, 0.02)
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)

        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        containers = []
        blocks = []
        for color in color_order:
            # Add container
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            containers.append(container_id)

            # Add block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

            # Add subgoal to place block in container
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/6,
                          language_goal=self.lang_template)

        # Add final goal to arrange containers in color order
        container_poses = [self.get_random_pose(env, container_size) for _ in color_order]
        self.add_goal(objs=containers, matches=np.eye(len(color_order)), targ_poses=container_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""multi-level-pyramid-construction"" in a python code block.
###

"," 
 multi-level-pyramid-construction: {'task-name': 'multi-level-pyramid-construction', 'task-description': 'Construct a two-level pyramid on a pallet using six blocks: three green and three blue. The first level should be a triangle created by placing the green blocks side by side. The second level should be built by placing the blue blocks on top of the green blocks, forming another triangle rotated 60 degrees with respect to the first one. The challenge lies in the precise placement of blocks, maintaining balance of the structure, and correct color arrangement.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MultiLevelPyramidConstruction(Task):
    """"""Construct a two-level pyramid on a pallet using six blocks: three green and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Construct a two-level pyramid on a pallet using six blocks: three green and three blue. The first level should be a triangle created by placing the green blocks side by side. The second level should be built by placing the blue blocks on top of the green blocks, forming another triangle rotated 60 degrees with respect to the first one.""
        self.task_completed_desc = ""done constructing pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.35, 0.35, 0.01)  # x, y, z dimensions for the pallet size
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_urdf = 'block/block.urdf'
        block_colors = [utils.COLORS['green']] * 3 + [utils.COLORS['blue']] * 3  # three green and three blue blocks

        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02),  # first level
                     (0, -0.025, 0.06), (0, 0.025, 0.06), (0, 0, 0.10)]  # second level
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (first level: green blocks).
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the green blocks"", row=""bottom""))

        # Goal: blocks are stacked in a pyramid (second level: blue blocks).
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the blue blocks"", row=""top""))
```

###"
"Write the pybullet simulation code for the task ""align-balls-in-colored-boxes"" in a python code block.
###

"," 
 align-balls-in-colored-boxes: {'task-name': 'align-balls-in-colored-boxes', 'task-description': 'On a tabletop, there are four balls and four boxes of different colors (red, blue, green, and yellow). Each ball is inside a box, but not corresponding to the color of the box. The task is to pick up each ball and place it in the box of the same color, in the specific sequence of red, blue, green and yellow from left to right. The challenge lies in the precise placement, color matching and sequence following.', 'assets-used': ['ball/ball.urdf', 'box/box-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignBallsInColoredBoxes(Task):
    """"""Align balls in colored boxes according to the color and sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} box""
        self.task_completed_desc = ""done aligning balls in boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add boxes.
        box_size = (0.12, 0.12, 0.12)
        box_urdf = 'box/box-template.urdf'
        box_poses = []
        boxes = []
        for i in range(4):
            box_pose = self.get_random_pose(env, box_size)
            box_id = env.add_object(box_urdf, box_pose, color=utils.COLORS[colors[i]])
            boxes.append(box_id)
            box_poses.append(box_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball.urdf'
        balls = []
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the box of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[box_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/4, 
                language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""colored-balls-sorting-in-corner"" in a python code block.
###

"," 
 colored-balls-sorting-in-corner: {'task-name': 'colored-balls-sorting-in-corner', 'task-description': 'There are four balls and four corners of different colors (red, blue, green, and yellow). Each ball is located at a corner, but not corresponding to the color of the corner. The task is to pick up each ball and place it in the corner of the same color, in the specific sequence of red, blue, green and yellow, starting from the leftmost corner to the rightmost. The challenge lies in the precise placement, color matching and sequence following.', 'assets-used': ['ball/ball-template.urdf', 'corner/corner-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColoredBallsSortingInCorner(Task):
    """"""Pick up each ball and place it in the corner of the same color, in the specific sequence of red, blue, green and yellow, starting from the leftmost corner to the rightmost.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} corner""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add corners.
        corner_size = (0.12, 0.12, 0)
        corner_urdf = 'corner/corner-template.urdf'
        corner_poses = []
        for i in range(4):
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, 'fixed', color=utils.COLORS[colors[i]])
            corner_poses.append(corner_pose)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the corner of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[corner_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-ball-insertion"" in a python code block.
###

"," 
 color-coordinated-ball-insertion: {'task-name': 'color-coordinated-ball-insertion', 'task-description': 'There are five differently-colored ell objects (red, blue, green, yellow, orange) and five sphere-shaped containers of matching colors. The task involves picking up each ell object and inserting it into the sphere container of the same color, but in a specific sequence from left to right: red, blue, green, yellow, and finally orange. The task is challenging due to the sequence, color coordination, and accuracy of insertion required.', 'assets-used': ['insertion/ell.urdf', 'sphere/sphere-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBallInsertion(Task):
    """"""Insert balls into the cylinders of the same color in the order of red, blue, green, and yellow.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""insert the {color} ball into the {color} cylinder""
        self.task_completed_desc = ""done inserting balls into cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.05, 0.05, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            env.add_object(cylinder_urdf, cylinder_pose, category='fixed', color=utils.COLORS[colors[i]])
            cylinder_poses.append(cylinder_pose)

        # Add balls.
        # x, y, z dimensions for the asset size
        balls = []
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        for i in range(4):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[colors[i]])
            balls.append(ball_id)

        # Goal: each ball is in the corresponding color cylinder.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-sequenced-pyramid-packing"" in a python code block.
###

"," 
 color-sequenced-pyramid-packing: {'task-name': 'color-sequenced-pyramid-packing', 'task-description': 'There are twelve cubes of different colors (three red, three green, three blue, and three yellow) scattered on the tabletop. The task is to pick up the cubes, sort them according to color into four pallets, and stack them in each pallet as a pyramid with the base layer containing two cubes and the top layer containing one cube. The challenge lies in the color-based sorting, the precise placement of cubes, and the construction of the pyramid in each pallet.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorSequencedPyramidPacking(Task):
    """"""Sort cubes by color into four pallets and stack them in each pallet as a pyramid""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""sort the {color} cubes into the pallet and stack them as a pyramid""
        self.task_completed_desc = ""done sorting and stacking cubes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.15, 0.15, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        for _ in range(4):
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed')
            pallet_poses.append(pallet_pose)

        # Cube colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['yellow']
        ]

        # Add cubes.
        # x, y, z dimensions for the asset size
        cube_size = (0.04, 0.04, 0.04)
        cube_urdf = 'block/block.urdf'

        objs = []
        for i in range(12):
            cube_pose = self.get_random_pose(env, cube_size)
            cube_id = env.add_object(cube_urdf, cube_pose, color=colors[i%4])
            objs.append(cube_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos for pallet_pose in pallet_poses]

        # Goal: cubes are sorted by color and stacked in a pyramid in each pallet.
        for i in range(4):
            self.add_goal(objs=objs[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(color=list(utils.COLORS.keys())[i]))
```

###"
"Write the pybullet simulation code for the task ""ball-sorting-with-blocks-barrier"" in a python code block.
###

"," 
 ball-sorting-with-blocks-barrier: {'task-name': 'ball-sorting-with-blocks-barrier', 'task-description': 'On a tabletop, there are four balls and four zones of different colors (red, blue, green, and yellow). Each ball is located behind a line of small blocks of the same color. The task is to pick up each ball and place it into the zone of the same color, but without knocking over the blocks. The challenge lies in the precise navigation over the block barriers and color matching.', 'assets-used': ['ball/ball-template.urdf', 'zone/zone.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallSortingWithBlocksBarrier(Task):
    """"""Pick up each ball and place it into the zone of the same color, but without knocking over the blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} zone without knocking over the blocks""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the balls and zones
        colors = ['red', 'blue', 'green', 'yellow']

        # Add zones and blocks.
        zone_size = (0.12, 0.12, 0)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        zone_urdf = 'zone/zone.urdf'
        zones = []
        blocks = []
        for color in colors:
            # Add zone of specific color
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zones.append(zone_pose)

            # Add line of blocks of the same color
            for _ in range(5):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[color])
            balls.append(ball_id)

        # Goal: each ball is in a zone of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[zones[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-block-bridge"" in a python code block.
###

"," 
 color-coordinated-block-bridge: {'task-name': 'color-coordinated-block-bridge', 'task-description': 'Construct a bridge by interleaving three differently colored blocks (red, blue, and green) on a pallet in a specific sequence - red block at the edges, blue block in the middle, and a green block on top of the red and blue blocks. Repeat this sequence until a bridge is formed across the length of the pallet.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBlockBridge(Task):
    """"""Construct a bridge by interleaving three differently colored blocks (red, blue, and green) on a pallet in a specific sequence - red block at the edges, blue block in the middle, and a green block on top of the red and blue blocks. Repeat this sequence until a bridge is formed across the length of the pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""construct a bridge by interleaving three differently colored blocks (red, blue, and green) on a pallet in a specific sequence""
        self.task_completed_desc = ""done constructing the bridge.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.30, 0.15, 0.02)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'

        objs = []
        for i in range(9):  # 3 sets of 3 colored blocks
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i % 3])
            objs.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0, 0.02), (0, 0.05, 0.02),  # bottom layer
                     (0, -0.05, 0.06), (0, 0, 0.06), (0, 0.05, 0.06),  # middle layer
                     (0, -0.05, 0.10), (0, 0, 0.10), (0, 0.05, 0.10)]  # top layer
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a bridge (bottom layer: red, blue, red).
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (middle layer: green, green, green).
        self.add_goal(objs=objs[3:6], matches=np.ones((3, 3)), targ_poses=targs[3:6], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template)

        # Goal: blocks are stacked in a bridge (top layer: red, blue, red).
        self.add_goal(objs=objs[6:], matches=np.ones((3, 3)), targ_poses=targs[6:], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                      language_goal=self.lang_template) 

```

###"
"Write the pybullet simulation code for the task ""color-coordinated-cylinder-pyramid"" in a python code block.
###

"," 
 color-coordinated-cylinder-pyramid: {'task-name': 'color-coordinated-cylinder-pyramid', 'task-description': 'Construct a pyramid on a pallet using four cylinders of different colors (red, blue, green, and yellow). The first level should consist of a red cylinder and a blue cylinder side by side. The second level should consist of a green cylinder placed on top of the red and blue cylinders. The third and final level should consist of a yellow cylinder placed on top of the green cylinder. The challenge lies in the precise placement of cylinders, maintaining the balance of the structure, and correct color arrangement.', 'assets-used': ['cylinder/cylinder-template.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedCylinderPyramid(Task):
    """"""Construct a pyramid on a pallet using four cylinders of different colors (red, blue, green, and yellow).""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = ""make the {row} row with {cylinder}""
        self.task_completed_desc = ""done stacking cylinder pyramid.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.005)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Cylinder colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            cylinders.append(cylinder_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0.05, 0.03),
                     (0, 0, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: cylinders are stacked in a pyramid (bottom row: red, blue).
        self.add_goal(objs=cylinders[:2], matches=np.ones((2, 2)), targ_poses=targs[:2], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*2,
                language_goal=self.lang_template.format(cylinder=""the red and blue cylinders"", row=""bottom""))

        # Goal: cylinders are stacked in a pyramid (middle row: green).
        self.add_goal(objs=cylinders[2:3], matches=np.ones((1, 1)), targ_poses=targs[2:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*1,
                language_goal=self.lang_template.format(cylinder=""the green cylinder"", row=""middle""))

        # Goal: cylinders are stacked in a pyramid (top row: yellow).
        self.add_goal(objs=cylinders[3:], matches=np.ones((1, 1)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 4, symmetries=[np.pi/2]*1,
                language_goal=self.lang_template.format(cylinder=""the yellow cylinder"", row=""top""))
```

###"
"Write the pybullet simulation code for the task ""sweep-and-sort-blocks"" in a python code block.
###

"," 
 sweep-and-sort-blocks: {'task-name': 'sweep-and-sort-blocks', 'task-description': 'Sweep a pile of small blocks of different colors (red, blue, green, and yellow) into their corresponding colored zones marked on the tabletop. The challenge lies in the sweeping action, precise placement, and color coordination.', 'assets-used': ['zone/zone.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils

class SweepAndSortBlocks(Task):
    """"""Sweep a pile of small blocks of different colors (red, blue, green, and yellow) into their corresponding colored zones marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""sweep the pile of {color} blocks into the {color} square""
        self.task_completed_desc = ""done sweeping and sorting.""
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add colored zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        zone_poses = []
        for color in colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add piles of colored blocks.
        block_urdf = 'block/small.urdf'
        block_size = (0.04, 0.04, 0.04)
        piles = []
        for color in colors:
            pile = []
            for _ in range(10):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                pile.append(block_id)
            piles.append(pile)

        # Add goals for each color.
        for i, color in enumerate(colors):
            self.add_goal(objs=piles[i], matches=np.ones((10, 1)), targ_poses=[zone_poses[i]], replace=True,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1,
                          language_goal=self.lang_template.format(color=color))
```

###"
"Write the pybullet simulation code for the task ""align-cylinders-in-zones"" in a python code block.
###

"," 
 align-cylinders-in-zones: {'task-name': 'align-cylinders-in-zones', 'task-description': 'Place four differently colored cylinders (red, blue, green, yellow) each into a matching colored zone. But, the zones are surrounded by small blocks, which the robot needs to move out of the way without knocking them out of their respective zones. The challenge includes precise placement of cylinders, color matching, and careful navigation around the small blocks.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class AlignCylindersInZones(Task):
    """"""Place four differently colored cylinders each into a matching colored zone. 
    The zones are surrounded by small blocks, which the robot needs to move out of the way 
    without knocking them out of their respective zones.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} cylinder in the {color} zone""
        self.task_completed_desc = ""done aligning cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Cylinder colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'

        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[colors[i]])
            cylinders.append(cylinder_id)

        # Add zones.
        # x, y, z dimensions for the asset size
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'

        zones = []
        for i in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, color=utils.COLORS[colors[i]], category='fixed')
            zones.append(zone_pose)

        # Add small blocks around the zones.
        # x, y, z dimensions for the asset size
        block_size = (0.02, 0.02, 0.02)
        block_urdf = 'block/small.urdf'

        for _ in range(16):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each cylinder is in a matching colored zone.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[zones[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""sphere-container-color-match"" in a python code block.
###

"," 
 sphere-container-color-match: {'task-name': 'sphere-container-color-match', 'task-description': 'On a tabletop, there are four spheres of different colors (red, blue, green, and yellow) inside four containers of a different color (red, blue, green, and yellow). The task is to pick up each sphere and place it into a container of the same color. The task is challenging due to the manipulation of spherical objects and the color coordination required.', 'assets-used': ['sphere/sphere.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SphereContainerColorMatch(Task):
    """"""Pick up each sphere and place it into a container of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 4
        self.lang_template = ""put the {color} sphere in the {color} container""
        self.task_completed_desc = ""done matching spheres and containers.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        containers = []
        for i in range(4):
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=colors[i])
            containers.append(container_id)

        # Add spheres.
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for i in range(4):
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=colors[i])
            spheres.append(sphere_id)

        # Goal: each sphere is in a container of the same color.
        for i in range(4):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(containers[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                    language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""insert-ell-along-square-path"" in a python code block.
###

"," 
 insert-ell-along-square-path: {'task-name': 'insert-ell-along-square-path', 'task-description': 'On the tabletop, there is a square path marked by small blocks. Along the path, there are four colored ell-shaped blocks (red, blue, green, and yellow) and four fixtures of matching colors. The task is to pick up each ell block and insert it into the fixture of the same color. However, the robot must move each ell block along the marked square path to reach the fixture. The task is challenging because it requires precise navigation along the path, color coordination, and insertion accuracy.', 'assets-used': ['block/small.urdf', 'insertion/ell.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class InsertEllAlongSquarePath(Task):
    """"""Pick up each ell block and insert it into the fixture of the same color. However, the robot must move each ell block along the marked square path to reach the fixture.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the {color} ell block into the {color} fixture""
        self.task_completed_desc = ""done inserting ell blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Ell block colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add ell blocks and fixtures.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        fixture_urdf = 'insertion/fixture.urdf'
        ell_blocks = []
        fixtures = []
        for color in colors:
            # Add ell block
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ell_blocks.append(ell_id)

            # Add fixture
            fixture_pose = self.get_random_pose(env, ell_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

        # Goal: each ell block is inserted into the fixture of the same color.
        for i in range(len(colors)):
            self.add_goal(objs=[ell_blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))

        # Add square path marked by small blocks.
        path_block_size = (0.02, 0.02, 0.02)
        path_block_urdf = 'block/small.urdf'
        path_block_color = utils.COLORS['gray']
        for _ in range(16):
            path_block_pose = self.get_random_pose(env, path_block_size)
            env.add_object(path_block_urdf, path_block_pose, color=path_block_color)
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-box-ball-matching"" in a python code block.
###

"," 
 color-coordinated-box-ball-matching: {'task-name': 'color-coordinated-box-ball-matching', 'task-description': 'On the tabletop, there are four boxes of different colors (red, blue, green, and yellow) and four balls of corresponding colors. The task is to pick up each ball and place it inside the box of the same color, however, the boxes are placed in a straight line with a row of small blocks acting as a barrier between the boxes and the balls. The challenge lies in the precise placement, color matching, and the navigation around the barrier without knocking over any small blocks.', 'assets-used': ['box/box-template.urdf', 'ball/ball-template.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedBoxBallMatching(Task):
    """"""Pick up each ball and place it inside the box of the same color, navigate around the barrier without knocking over any small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} box""
        self.task_completed_desc = ""done placing balls in boxes.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for the boxes and balls
        colors = ['red', 'blue', 'green', 'yellow']

        # Add boxes.
        box_size = (0.05, 0.05, 0.05)
        box_urdf = 'box/box-template.urdf'
        box_poses = []
        for color in colors:
            box_pose = self.get_random_pose(env, box_size)
            env.add_object(box_urdf, box_pose, color=color, category='fixed')
            box_poses.append(box_pose)

        # Add balls.
        balls = []
        ball_size = (0.02, 0.02, 0.02)
        ball_urdf = 'ball/ball-template.urdf'
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add small blocks as barriers.
        barrier_size = (0.01, 0.01, 0.01)
        barrier_urdf = 'block/small.urdf'
        for _ in range(10):
            barrier_pose = self.get_random_pose(env, barrier_size)
            env.add_object(barrier_urdf, barrier_pose, category='fixed')

        # Goal: each ball is in the box of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[box_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""cylinder-balancing-and-placement"" in a python code block.
###

"," 
 cylinder-balancing-and-placement: {'task-name': 'cylinder-balancing-and-placement', 'task-description': 'On a table, there are three differently colored cylinders (red, green, and blue) and three square zones of matching colors. The task involves picking up each cylinder and balancing it on its end at the center of the corresponding colored zone, in the sequence of red, green, and blue from left to right. The task is challenging due to precise balancing required in placing the cylinders, color matching, and sequence following.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderBalancingAndPlacement(Task):
    """"""Pick up each cylinder and balance it on its end at the center of the corresponding colored zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""balance the {color} cylinder in the {color} zone""
        self.task_completed_desc = ""done balancing and placing cylinders.""
        self.colors = ['red', 'green', 'blue']
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for color in self.colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.12)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in self.colors:
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[color])
            cylinders.append(cylinder_id)

        # Goal: each cylinder is balanced in the corresponding colored zone.
        for i in range(len(cylinders)):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=self.lang_template.format(color=self.colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-sphere-and-cylinder-assembly"" in a python code block.
###

"," 
 color-coordinated-sphere-and-cylinder-assembly: {'task-name': 'color-coordinated-sphere-and-cylinder-assembly', 'task-description': 'The robot starts with four spheres of different colors (red, blue, green, yellow) and four cylinders of matching colors. The task is to pick up each sphere and place it on top of the cylinder of the same color, forming four sphere-and-cylinder pairs. However, the challenge here is to do this in a specific color sequence - red, blue, green, and finally yellow.', 'assets-used': ['sphere/sphere-template.urdf', 'cylinder/cylinder-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedSphereAndCylinderAssembly(Task):
    """"""Pick up each sphere and place it on top of the cylinder of the same color, in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere on the {color} cylinder""
        self.task_completed_desc = ""done placing spheres on cylinders.""
        self.colors = ['red', 'blue', 'green', 'yellow']
        self.color_sequence = ['red', 'blue', 'green', 'yellow']

    def reset(self, env):
        super().reset(env)

        # Add spheres and cylinders.
        sphere_size = (0.05, 0.05, 0.05)
        cylinder_size = (0.05, 0.05, 0.1)
        sphere_template = 'sphere/sphere-template.urdf'
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Add spheres and cylinders of each color.
        for color in self.colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            sphere_id = env.add_object(sphere_template, sphere_pose, color=color)
            cylinder_id = env.add_object(cylinder_template, cylinder_pose, color=color)

            # Goal: each sphere is on top of the cylinder of the same color.
            self.add_goal(objs=[sphere_id], matches=np.ones((1, 1)), targ_poses=[cylinder_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=color))

        # The task is completed in a specific color sequence.
        self.color_sequence = ['red', 'blue', 'green', 'yellow']
```

###"
"Write the pybullet simulation code for the task ""sequential-block-insertion"" in a python code block.
###

"," 
 sequential-block-insertion: {'task-name': 'sequential-block-insertion', 'task-description': 'There are four blocks of different colors (red, blue, green, yellow) and four fixtures of matching colors. The task involves picking up each block and inserting it into the fixture of the same color, in the specific sequence of red, blue, green, and yellow. However, the challenge lies in the fact that the blocks and fixtures are initially arranged in a mixed order, demanding careful navigation, precise insertion, color matching, and sequence following.', 'assets-used': ['insertion/fixture.urdf', 'block/block.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SequentialBlockInsertion(Task):
    """"""Pick up blocks of different colors and insert them into the fixture of the same color in a specific sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the sequence of colors
        colors = ['red', 'blue', 'green', 'yellow']

        # Add fixtures.
        # x, y, z dimensions for the asset size
        fixture_size = (0.12, 0.12, 0)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add blocks.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Goal: each block is in the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks), language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""sequential-insertion-and-stacking"" in a python code block.
###

"," 
 sequential-insertion-and-stacking: {'task-name': 'sequential-insertion-and-stacking', 'task-description': 'The tabletop contains three fixtures and three ell-shaped blocks of different colors - red, blue, and green. The task is to first pick up and insert each ell block into the corresponding colored fixture in the sequence of red, blue, and green. After successful insertion, the robot must pick up the three blocks again from the fixtures and stack them in a corner of the tabletop in the same color sequence - red at the bottom, blue in the middle, and green on top.', 'assets-used': ['insertion/ell.urdf', 'insertion/fixture.urdf', 'corner/corner-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class SequentialInsertionAndStacking(Task):
    """"""Pick up and insert each ell block into the corresponding colored fixture in the sequence of red, blue, and green. After successful insertion, pick up the three blocks again from the fixtures and stack them in a corner of the tabletop in the same color sequence - red at the bottom, blue in the middle, and green on top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""insert the {color} ell block into the {color} fixture and then stack them in the corner""
        self.task_completed_desc = ""done inserting and stacking.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0)
        fixture_urdf = 'insertion/fixture.urdf'
        fixture_poses = []
        colors = ['red', 'blue', 'green']
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            env.add_object(fixture_urdf, fixture_pose, category='fixed', color=utils.COLORS[color])
            fixture_poses.append(fixture_pose)

        # Add ell blocks.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell block is in the corresponding colored fixture.
        for i in range(3):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[fixture_poses[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/3)
            self.lang_goals.append(self.lang_template.format(color=colors[i]))

        # Add corner.
        corner_size = (0.12, 0.12, 0)
        corner_pose = self.get_random_pose(env, corner_size)
        corner_urdf = 'corner/corner-template.urdf'
        env.add_object(corner_urdf, corner_pose, category='fixed')

        # Goal: ell blocks are stacked in the corner in the color sequence - red at the bottom, blue in the middle, and green on top.
        stack_poses = [(0, 0, 0.04), (0, 0, 0.08), (0, 0, 0.12)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in stack_poses]
        self.add_goal(objs=ells, matches=np.ones((3, 3)), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=""stack the ell blocks in the corner in the color sequence - red at the bottom, blue in the middle, and green on top"")
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-block-shifting"" in a python code block.
###

"," 
 color-coordinated-block-shifting: {'task-name': 'color-coordinated-block-shifting', 'task-description': 'On a tabletop, there are three zones marked in three different colors (red, blue, and green) and nine blocks of matching colors (three red, three blue, and three green). Each zone initially contains three blocks of a single color, but the colors of the blocks and zones do not match. The task involves picking up each block and precisely placing it in the zone of the same color. However, there are a few small blocks randomly scattered in the path between the zones. The robot has to strategically navigate around these blocks without knocking them over while transporting the blocks to the corresponding zones. The challenge lies in the precise navigation, placement of the blocks, color matching while avoiding the blocks.', 'assets-used': ['zone/zone.urdf', 'block/block.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBlockShifting(Task):
    """"""Pick up each block and precisely place it in the zone of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""move the {color} blocks to the {color} zone""
        self.task_completed_desc = ""done moving blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_colors = ['yellow', 'blue', 'green']
        zone_poses = []
        for color in zone_colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in zone_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add small blocks as obstacles.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'stacking/block.urdf'
        for _ in range(5):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is in the zone of the same color.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/9,
                          language_goal=self.lang_template.format(color=zone_colors[i//3]))
```

###"
"Write the pybullet simulation code for the task ""guided-block-path"" in a python code block.
###

"," 
 guided-block-path: {'task-name': 'guided-block-path', 'task-description': 'On the tabletop, there are four colored blocks (red, blue, green, and yellow) and four lines of the corresponding colors. The task is to pick up each block and move it along the line of the same color from start to end. The challenge lies in precise navigation along the line, color coordination, and block manipulation.', 'assets-used': ['block/block.urdf', 'line/line-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class GuidedBlockPath(Task):
    """"""Pick up each block and move it along the line of the same color from start to end.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""move the {color} block along the {color} line from start to end""
        self.task_completed_desc = ""done moving blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and corresponding names
        colors = [utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'], utils.COLORS['yellow']]
        color_names = ['red', 'blue', 'green', 'yellow']

        # Add lines and blocks.
        # x, y, z dimensions for the asset size
        line_size = (0.3, 0.01, 0.01)
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        line_urdf = 'line/line-template.urdf'

        blocks = []
        lines = []
        for i in range(4):
            # Add line
            line_pose = self.get_random_pose(env, line_size)
            env.add_object(line_urdf, line_pose, color=colors[i], category='fixed')
            lines.append(line_pose)

            # Add block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

            # Add goal
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[line_pose], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=color_names[i]))
```

###"
"Write the pybullet simulation code for the task ""mixed-color-block-barrier-insertion"" in a python code block.
###

"," 
 mixed-color-block-barrier-insertion: {'task-name': 'mixed-color-block-barrier-insertion', 'task-description': 'There are four different colored blocks (red, blue, green, and yellow), and four fixtures in corresponding colors. Two barriers, each made of three blocks (orange, purple, and brown), are placed in between the blocks and fixtures, forming a path that the robot must navigate. The task involves picking up each colored block, navigating the barriers, and inserting each block into the fixture of the same color. The fixtures are arranged in a sequence from left to right: red, blue, green, and yellow, providing a challenge in precise navigation, color coordination, and insertion.', 'assets-used': ['block/block.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class MixedColorBlockBarrierInsertion(Task):
    """"""Pick up each colored block, navigate the barriers, and insert each block into the fixture of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {color} block into the {color} fixture""
        self.task_completed_desc = ""done inserting blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for blocks and fixtures
        colors = ['red', 'blue', 'green', 'yellow']

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Add fixtures.
        fixture_size = (0.06, 0.06, 0.06)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color])
            fixtures.append(fixture_id)

        # Add barriers.
        barrier_size = (0.12, 0.04, 0.04)
        barrier_colors = ['orange', 'purple', 'brown']
        for _ in range(2):
            for color in barrier_colors:
                barrier_pose = self.get_random_pose(env, barrier_size)
                env.add_object(block_urdf, barrier_pose, color=utils.COLORS[color])

        # Goal: each block is inserted into the fixture of the same color.
        for i in range(len(blocks)):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(blocks),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""ball-in-bowl-obstacle-course"" in a python code block.
###

"," 
 ball-in-bowl-obstacle-course: {'task-name': 'ball-in-bowl-obstacle-course', 'task-description': 'With the tabletop setup consisting of a maze of small blocks, the task requires the robot to pick up four balls of different colors (red, blue, green, yellow) and place each of them into the corresponding colored bowls strategically positioned at different corners of the maze, without knocking over any blocks, demanding careful navigation and color coordination.', 'assets-used': ['ball/ball-template.urdf', 'block/small.urdf', 'bowl/bowl.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallInBowlObstacleCourse(Task):
    """"""Navigate through a maze of blocks, pick up balls of different colors and place them in the corresponding colored bowls.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""navigate through the maze and place the {color} ball in the {color} bowl""
        self.task_completed_desc = ""done placing balls in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks to form a maze.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(10):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose, category='fixed')

        # Add balls of different colors.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add bowls of different colors at different corners of the maze.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for color in colors:
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color, category='fixed')
            bowls.append(bowl_id)

        # Goal: each ball is in the bowl of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(bowls[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""ball-in-bowl-obstacle-course-new"" in a python code block.
###

"," 
 ball-in-bowl-obstacle-course-new: {'task-name': 'ball-in-bowl-obstacle-course-new', 'task-description': 'With the tabletop setup consisting of a maze of small blocks, the task requires the robot to pick up four balls of different colors (red, blue, green, yellow) and place each of them into the corresponding colored bowls strategically positioned at different corners of the maze, without knocking over any blocks, demanding careful navigation and color coordination.', 'assets-used': ['ball/ball-template.urdf', 'block/small.urdf', 'bowl/bowl.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class BallInBowlObstacleCourseNew(Task):
    """"""Navigate through a maze of blocks, pick up balls of different colors and place them in the corresponding colored bowls.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} ball in the {color} bowl""
        self.task_completed_desc = ""done placing balls in bowls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks to form a maze.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(10):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose, category='fixed')

        # Add balls of different colors.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        colors = ['red', 'blue', 'green', 'yellow']
        balls = []
        for color in colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add bowls of different colors at different corners of the maze.
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for color in colors:
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color, category='fixed')
            bowls.append(bowl_id)

        # Goal: each ball is in the bowl of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(bowls[i])], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                    language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-arch-construction"" in a python code block.
###

"," 
 color-coordinated-arch-construction: {'task-name': 'color-coordinated-arch-construction', 'task-description': 'The task is to construct an arch using six blocks: three red and three blue. The blocks are initially placed in a container. The robot needs to pick each block and place it on a pallet in the following arrangement: place two red blocks in parallel on the pallet, then place a blue block on top of the red blocks to form an arch. Repeat the process with the remaining blocks, placing them on top of the first arch to form a second layer. The task is challenging due to the need for precise placement of the blocks and maintaining the balance of the structure.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedArchConstruction(Task):
    """"""Construct an arch using six blocks: three red and three blue.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 6
        self.lang_template = ""construct an arch using six blocks: three red and three blue""
        self.task_completed_desc = ""done constructing arch.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.15, 0.15, 0.005)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Block colors.
        colors = [utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue'],
                  utils.COLORS['red'], utils.COLORS['red'], utils.COLORS['blue']]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.02), (0, 0.05, 0.02),
                     (0, 0, 0.06), (0, -0.05, 0.08),
                     (0, 0.05, 0.08), (0, 0, 0.12)]
        targs = [(utils.apply(pallet_pose, i), pallet_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in an arch (bottom row: red, red, blue).
        self.add_goal(objs=blocks[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)

        # Goal: blocks are stacked in an arch (top row: red, red, blue).
        self.add_goal(objs=blocks[3:], matches=np.ones((3, 3)), targ_poses=targs[3:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                language_goal=self.lang_template)
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-zone-arrangement"" in a python code block.
###

"," 
 color-coordinated-zone-arrangement: {'task-name': 'color-coordinated-zone-arrangement', 'task-description': 'On the tabletop, there are nine blocks of three different colors (three red, three blue, and three green) and three pallets of matching colors (one red, one blue, one green). The task is to pick up each block and place it on the pallet of the same color, arranging the blocks on each pallet in a line. However, there are a few small blocks randomly scattered on the tabletop, which the robot has to navigate around without knocking them over while transporting the blocks to the corresponding pallets. The challenge lies in the precise navigation, placement of the blocks, color matching, and maintaining the balance on the pallets.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedZoneArrangement(Task):
    """"""Pick up blocks of different colors and place them on the pallets of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {color} blocks on the {color} pallet""
        self.task_completed_desc = ""done arranging blocks on pallets.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallets.
        # x, y, z dimensions for the asset size
        pallet_size = (0.12, 0.12, 0.02)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_colors = ['red', 'blue', 'green']
        pallet_poses = []
        for color in pallet_colors:
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed', color=utils.COLORS[color])
            pallet_poses.append(pallet_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        for color in pallet_colors:
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

        # Add small blocks as obstacles.
        small_block_size = (0.02, 0.02, 0.02)
        small_block_urdf = 'block/small.urdf'
        for _ in range(5):
            small_block_pose = self.get_random_pose(env, small_block_size)
            env.add_object(small_block_urdf, small_block_pose)

        # Goal: each block is on the pallet of the same color.
        for i in range(9):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[pallet_poses[i // 3]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 9,
                          language_goal=self.lang_template.format(color=pallet_colors[i // 3]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-cylinder-stand-assembly"" in a python code block.
###

"," 
 color-coordinated-cylinder-stand-assembly: {'task-name': 'color-coordinated-cylinder-stand-assembly', 'task-description': 'The robot starts with four cylinders of different colors (red, blue, green, yellow) and four stands of matching colors. The task is to pick up each cylinder and place it on top of the stand of the same color, forming four cylinder-and-stand pairs. However, the challenge here is to do this in a specific color sequence - green, yellow, blue, and finally red, while also ensuring that the cylinders do not topple over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedCylinderStandAssembly(Task):
    """"""Pick up each cylinder and place it on top of the stand of the same color, in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the {color} cylinder on the {color} stand""
        self.task_completed_desc = ""done placing cylinders on stands.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['green', 'yellow', 'blue', 'red']
        color_sequence = [utils.COLORS[color] for color in colors]

        # Add stands.
        stand_size = (0.04, 0.04, 0.04)
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i in range(4):
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, color=color_sequence[i], category='fixed')
            stand_poses.append(stand_pose)

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color_sequence[i])
            cylinders.append(cylinder_id)

        # Goal: each cylinder is on the stand of the same color, in the specified color sequence.
        for i in range(4):
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[stand_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4, 
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-ball-stacking"" in a python code block.
###

"," 
 color-coordinated-ball-stacking: {'task-name': 'color-coordinated-ball-stacking', 'task-description': 'There are four balls of different colors (red, blue, green, yellow), and four containers of matching colors on the table. The task is to pick up each ball and stack it on top of the corresponding colored container. However, the stacking should be done in a specific color sequence - blue at the bottom, followed by yellow, then green, and finally red at the top. This task enforces challenging skills due to the precision required for stacking the balls, color coordination, and sequencing.', 'assets-used': ['ball/ball-template.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedBallStacking(Task):
    """"""Stack balls on top of the corresponding colored containers in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""stack the balls on top of the corresponding colored containers in the sequence blue, yellow, green, red""
        self.task_completed_desc = ""done stacking balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the color sequence
        color_sequence = ['blue', 'yellow', 'green', 'red']

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        container_poses = []
        containers = []
        for color in color_sequence:
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[color])
            container_poses.append(container_pose)
            containers.append(container_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in color_sequence:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=utils.COLORS[color])
            balls.append(ball_id)

        # Goal: each ball is stacked on top of the corresponding colored container in the color sequence.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[container_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                language_goal=self.lang_template.format(obj=color_sequence[i]))

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_ball = np.random.rand() > 0.5
            urdf = ball_urdf if is_ball else container_urdf
            size = ball_size if is_ball else container_size
            pose = self.get_random_pose(env, obj_size=size)
            color = np.random.choice(list(utils.COLORS.keys()))

            obj_id = env.add_object(urdf, pose, color=utils.COLORS[color])
            n_distractors += 1
```

###"
"Write the pybullet simulation code for the task ""color-coded-blocks-on-corner"" in a python code block.
###

"," 
 color-coded-blocks-on-corner: {'task-name': 'color-coded-blocks-on-corner', 'task-description': 'On a tabletop, there are four blocks of different colors (red, blue, green, and yellow) and a corner structure. The task involves picking up each block and placing it in the corner structure in a specific color sequence: from left to right, place red, blue, green, and finally yellow. The blocks must be arranged such that they form a straight line along the corner. The challenge lies in the precise placement, color coordination, and maintaining the balance of the blocks along the corner.', 'assets-used': ['block/block.urdf', 'corner/corner-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCodedBlocksOnCorner(Task):
    """"""Pick up blocks of different colors and place them in a corner structure in a specific color sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the blocks in the corner in the sequence red, blue, green, yellow""
        self.task_completed_desc = ""done placing blocks in the corner.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corner structure.
        corner_size = (0.15, 0.15, 0.05)
        corner_pose = self.get_random_pose(env, corner_size)
        corner_urdf = 'corner/corner-template.urdf'
        env.add_object(corner_urdf, corner_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0, 0.08)]
        targs = [(utils.apply(corner_pose, i), corner_pose[1]) for i in place_pos]

        # Goal: blocks are placed in the corner in the sequence red, blue, green, yellow.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targs[i]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 4, 
                    language_goal=self.lang_template.format(blocks=""the red, blue, green, yellow blocks""))
```

###"
"Write the pybullet simulation code for the task ""insertion-in-color-sequenced-zones"" in a python code block.
###

"," 
 insertion-in-color-sequenced-zones: {'task-name': 'insertion-in-color-sequenced-zones', 'task-description': 'On the table, there are four differently-colored insertion ell objects (red, blue, green, yellow) and four zones on the tabletop marked in the same colors. Initially, each ell is placed in a zone but not corresponding to the color of the zone. The task is to pick up each ell and place it in the zone of the same color, in the specific sequence of red, blue, green, and yellow from left to right, requiring careful navigation, precise placement, color matching, and sequence following.', 'assets-used': ['insertion/ell.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class InsertionInColorSequencedZones(Task):
    """"""Pick up each ell and place it in the zone of the same color, in the specific sequence of red, blue, green, and yellow from left to right.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ell in the {color} zone""
        self.task_completed_desc = ""done placing ells in color sequenced zones.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Ell colors.
        colors = ['red', 'blue', 'green', 'yellow']

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(4):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add ells.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for i in range(4):
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[colors[i]])
            ells.append(ell_id)

        # Goal: each ell is in the zone of the same color.
        for i in range(4):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-zone-stacking"" in a python code block.
###

"," 
 color-coordinated-zone-stacking: {'task-name': 'color-coordinated-zone-stacking', 'task-description': 'On the tabletop, there are three zones and nine blocks of three different colors (red, blue, green). Each color has three blocks and the blocks are scattered randomly on the table. The task is to pick up the blocks and stack them in the zones to form a pyramid shape. Each pyramid should contain blocks of the same color with two blocks on the base and one block on top. The zones with the pyramids should be arranged in a straight line in the following color order: red, blue, green from left to right. The challenge lies in the color coordination, precise stacking and the arrangement of the zones.', 'assets-used': ['block/block.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCoordinatedZoneStacking(Task):
    """"""Pick up blocks of different colors and stack them in zones to form a pyramid.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""stack the blocks in the zones to form a pyramid""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(3):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(9):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i//3])
            blocks.append(block_id)

        # Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(zone_poses[i//3], place_pos[i%3]), zone_poses[i//3][1]) for i in range(9)]

        # Goal: blocks are stacked in a pyramid in each zone.
        for i in range(3):
            self.add_goal(objs=blocks[i*3:(i+1)*3], matches=np.ones((3, 3)), targ_poses=targs[i*3:(i+1)*3], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*3,
                          language_goal=self.lang_template.format(blocks=""the red, blue and green blocks"",
                                                             row=""bottom""))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-cylinder-ball-match"" in a python code block.
###

"," 
 color-coordinated-cylinder-ball-match: {'task-name': 'color-coordinated-cylinder-ball-match', 'task-description': 'On the tabletop, there are four cylinders of different colors (red, blue, green, and yellow) and four balls of corresponding colors. The task is to pick up each ball and place it on top of the cylinder of the same color without the ball rolling off. However, there are small blocks scattered randomly on the table that the robot has to navigate around without knocking them over. The challenge lies in the precise placement of the balls on top of the cylinders, color matching, and navigation around the blocks.', 'assets-used': ['cylinder/cylinder-template.urdf', 'ball/ball-template.urdf', 'block/small.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedCylinderBallMatch(Task):
    """"""Pick up each ball and place it on top of the cylinder of the same color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball on the {color} cylinder""
        self.task_completed_desc = ""done placing balls on cylinders.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add cylinders.
        # x, y, z dimensions for the asset size
        cylinder_size = (0.04, 0.04, 0.1)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinder_colors = ['red', 'blue', 'green', 'yellow']
        cylinder_poses = []
        cylinders = []
        for color in cylinder_colors:
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color)
            cylinder_poses.append(cylinder_pose)
            cylinders.append(cylinder_id)

        # Add balls.
        # x, y, z dimensions for the asset size
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in cylinder_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add blocks as obstacles.
        # x, y, z dimensions for the asset size
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/small.urdf'
        for _ in range(5):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each ball is on top of the cylinder of the same color.
        for i in range(len(balls)):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[i]], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1/len(balls),
                language_goal=self.lang_template.format(color=cylinder_colors[i]))
```

###"
"Write the pybullet simulation code for the task ""multi-level-insertion-and-zone-matching"" in a python code block.
###

"," 
 multi-level-insertion-and-zone-matching: {'task-name': 'multi-level-insertion-and-zone-matching', 'task-description': 'There are three levels of zones marked on the tabletop - the first level is red, second is blue, and third is green. On each level, there are large, medium, and small ell-shaped objects in corresponding colors. The task is to pick up each ell object from its current position and insert it into the corresponding colored zone on the same level, but in a specific order - large, medium, and small. The challenge lies in the precise control of insertion, color coordination, and the multi-level structure of the environment.', 'assets-used': ['zone/zone.urdf', 'insertion/ell.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class MultiLevelInsertionAndZoneMatching(Task):
    """"""Pick up ell objects from their current position and insert them into the corresponding colored zone on the same level, in a specific order - large, medium, and small.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""insert the {size} {color} ell into the {color} zone on the same level""
        self.task_completed_desc = ""done inserting.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_sizes = [(0.12, 0.12, 0), (0.12, 0.12, 0.05), (0.12, 0.12, 0.1)]
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        zone_colors = ['red', 'blue', 'green']
        for i in range(3):
            zone_pose = self.get_random_pose(env, zone_sizes[i])
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[zone_colors[i]])
            zone_poses.append(zone_pose)

        # Add ell objects.
        ell_sizes = [(0.08, 0.08, 0.02), (0.06, 0.06, 0.015), (0.04, 0.04, 0.01)]
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for i in range(3):
            for j in range(3):
                ell_pose = self.get_random_pose(env, ell_sizes[j])
                ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[zone_colors[i]])
                ells.append(ell_id)

        # Goal: each ell object is in the corresponding colored zone on the same level.
        for i in range(9):
            self.add_goal(objs=[ells[i]], matches=np.ones((1, 1)), targ_poses=[zone_poses[i//3]], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1/9,
                          language_goal=self.lang_template.format(size=['large', 'medium', 'small'][i%3], color=zone_colors[i//3]))
```

###"
"Write the pybullet simulation code for the task ""color-cued-ball-corner-sorting"" in a python code block.
###

"," 
 color-cued-ball-corner-sorting: {'task-name': 'color-cued-ball-corner-sorting', 'task-description': 'On a tabletop, there are four different colored balls (red, blue, green, yellow) and four corners marked with corresponding colors using the corner template. The task involves picking up each ball and precisely placing it in the corner of the same color. However, there is a rectangular zone in the middle of the table marked by small blocks. The robot has to strategically navigate around this zone without touching the blocks while transporting the balls to the corresponding corners. The challenge lies in the precise navigation, placement of the balls, and color matching while avoiding the blocks.', 'assets-used': ['ball/ball-template.urdf', 'corner/corner-template.urdf', 'block/block_for_anchors.urdf', 'zone/zone.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorCuedBallCornerSorting(Task):
    """"""Pick up each colored ball and place it in the corner of the same color while avoiding a zone marked by small blocks.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} ball in the {color} corner""
        self.task_completed_desc = ""done sorting balls.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add corners.
        corner_size = (0.05, 0.05, 0.05)
        corner_urdf = 'corner/corner-template.urdf'
        corner_colors = ['red', 'blue', 'green', 'yellow']
        corner_poses = []
        for color in corner_colors:
            corner_pose = self.get_random_pose(env, corner_size)
            env.add_object(corner_urdf, corner_pose, color=color, category='fixed')
            corner_poses.append(corner_pose)

        # Add balls.
        balls = []
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball-template.urdf'
        for color in corner_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            ball_id = env.add_object(ball_urdf, ball_pose, color=color)
            balls.append(ball_id)

        # Add zone.
        zone_size = (0.2, 0.2, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block_for_anchors.urdf'
        for _ in range(4):
            block_pose = self.get_random_pose(env, block_size)
            env.add_object(block_urdf, block_pose)

        # Goal: each ball is in the corner of the same color.
        for i in range(4):
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[corner_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=corner_colors[i]))
```

###"
"Write the pybullet simulation code for the task ""cylinder-ring-stack"" in a python code block.
###

"," 
 cylinder-ring-stack: {'task-name': 'cylinder-ring-stack', 'task-description': 'On the tabletop, there are four differently colored cylinders (red, blue, green, yellow) and four blocks of matching colors. The task involves picking up each block and stacking it on top of the corresponding colored cylinder. However, each cylinder and block pair should be stacked inside a differently colored container (color sequence: red cylinder and block in blue container, blue in green, green in yellow, and yellow in red). The task offers challenges in multi-object manipulation, color coordination, and precise stacking in a confined space.', 'assets-used': ['cylinder/cylinder-template.urdf', 'block/block.urdf', 'container/container-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class CylinderRingStack(Task):
    """"""Pick up each block and stack it on top of the corresponding colored cylinder. 
    Each cylinder and block pair should be stacked inside a differently colored container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""stack the {color} block on the {color} cylinder in the {container_color} container""
        self.task_completed_desc = ""done stacking.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors for cylinders, blocks and containers
        colors = ['red', 'blue', 'green', 'yellow']
        container_colors = ['blue', 'green', 'yellow', 'red']

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.04)
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(4):
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=utils.COLORS[colors[i]])
            cylinders.append(cylinder_id)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[colors[i]])
            blocks.append(block_id)

        # Add containers.
        container_size = (0.12, 0.12, 0.12)
        container_urdf = 'container/container-template.urdf'
        containers = []
        for i in range(4):
            container_pose = self.get_random_pose(env, container_size)
            container_id = env.add_object(container_urdf, container_pose, color=utils.COLORS[container_colors[i]])
            containers.append(container_id)

        # Goal: each block is stacked on the corresponding colored cylinder inside a differently colored container.
        for i in range(4):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=self.lang_template.format(color=colors[i], container_color=container_colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-coordinated-sphere-on-pallet-pyramid"" in a python code block.
###

"," 
 color-coordinated-sphere-on-pallet-pyramid: {'task-name': 'color-coordinated-sphere-on-pallet-pyramid', 'task-description': 'On the tabletop, there are three pallets and nine blocks of three different colors (red, blue, green). Each color has three blocks and the blocks are scattered randomly on the table. The task is to pick up the blocks and stack them on the pallets to form a pyramid shape. Each pyramid should contain blocks of the same color with two blocks on the base and one block on top. Additionally, there are three spheres of matching colors (red, blue, green). The task is to pick up each sphere and place it on top of the corresponding colored pyramid. The pallets with the pyramids and spheres should be arranged in a straight line in the following color order: red, blue, green from left to right. The challenge lies in the color coordination, precise stacking, and the arrangement of the pallets.', 'assets-used': ['block/block.urdf', 'pallet/pallet.urdf', 'sphere/sphere.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class ColorCoordinatedSphereOnPalletPyramid(Task):
    """"""Build a pyramid of colored blocks on pallets and place a matching colored sphere on top.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""build a pyramid of {color} blocks on the pallet and place the {color} sphere on top""
        self.task_completed_desc = ""done building color-coordinated pyramids.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Pallets and Blocks
        pallet_size = (0.15, 0.15, 0.01)
        block_size = (0.04, 0.04, 0.04)
        pallet_urdf = 'pallet/pallet.urdf'
        block_urdf = 'block/block.urdf'

        # Colors for blocks and spheres
        colors = ['red', 'blue', 'green']
        color_objects = {}

        # Add pallets and blocks
        for color in colors:
            # Add pallet
            pallet_pose = self.get_random_pose(env, pallet_size)
            env.add_object(pallet_urdf, pallet_pose, category='fixed')

            # Add blocks
            block_ids = []
            for _ in range(3):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                block_ids.append(block_id)

            color_objects[color] = {'pallet': pallet_pose, 'blocks': block_ids}

        # Spheres
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'

        # Add spheres
        for color in colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=utils.COLORS[color])
            color_objects[color]['sphere'] = sphere_id

        # Goals
        for color in colors:
            # Goal: blocks are stacked in a pyramid on the pallet
            block_poses = [(0, -0.02, 0.02), (0, 0.02, 0.02), (0, 0, 0.06)]
            targs = [(utils.apply(color_objects[color]['pallet'], i), color_objects[color]['pallet'][1]) for i in block_poses]

            self.add_goal(objs=color_objects[color]['blocks'], matches=np.ones((3, 3)), targ_poses=targs, replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3,
                    language_goal=self.lang_template.format(color=color))

            # Goal: sphere is placed on top of the pyramid
            sphere_pose = (0, 0, 0.1)
            targ = (utils.apply(color_objects[color]['pallet'], sphere_pose), color_objects[color]['pallet'][1])

            self.add_goal(objs=[color_objects[color]['sphere']], matches=np.ones((1, 1)), targ_poses=[targ], replace=False,
                    rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2],
                          language_goal=self.lang_template.format(color=color))
```

###"
"Write the pybullet simulation code for the task ""color-sequenced-sphere-placement"" in a python code block.
###

"," 
 color-sequenced-sphere-placement: {'task-name': 'color-sequenced-sphere-placement', 'task-description': 'On the tabletop, there are four spheres of different colors (red, blue, green, and yellow) and four colored squares of matching colors. The task involves picking up each sphere and precisely placing it in the center of the square of the same color. However, the spheres must be placed in a specific sequence - red first, then blue, then green, and finally yellow. The task is challenging due to the need for precise placement, color coordination, and sequence following.', 'assets-used': ['sphere/sphere.urdf', 'square/square-template.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorSequencedSpherePlacement(Task):
    """"""Pick up spheres of different colors and place them in the center of the square of the same color in a specific sequence.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""place the {color} sphere in the {color} square""
        self.task_completed_desc = ""done placing spheres.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their sequence
        colors = ['red', 'blue', 'green', 'yellow']

        # Add squares of different colors
        square_size = (0.1, 0.1, 0.005)
        square_urdf = 'square/square-template.urdf'
        square_poses = []
        for color in colors:
            square_pose = self.get_random_pose(env, square_size)
            env.add_object(square_urdf, square_pose, 'fixed', color=color)
            square_poses.append(square_pose)

        # Add spheres of different colors
        sphere_size = (0.04, 0.04, 0.04)
        sphere_urdf = 'sphere/sphere.urdf'
        spheres = []
        for color in colors:
            sphere_pose = self.get_random_pose(env, sphere_size)
            sphere_id = env.add_object(sphere_urdf, sphere_pose, color=color)
            spheres.append(sphere_id)

        # Goal: each sphere is in the square of the same color, in the correct sequence
        for i in range(len(colors)):
            self.add_goal(objs=[spheres[i]], matches=np.ones((1, 1)), targ_poses=[square_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(colors),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""color-ordered-insertion-new"" in a python code block.
###

"," 
 color-ordered-insertion-new: {'task-name': 'color-ordered-insertion-new', 'task-description': 'There are four differently-colored ell objects (red, blue, green, yellow) and a corresponding set of color-coded fixtures. The task involves picking up each ell object and inserting it into the matching color fixture in a specific order: from left to right, insert red, blue, green, and finally yellow. The challenge lies in the precise manipulation of the ell objects and the color-coordination required.', 'assets-used': ['insertion/ell.urdf', 'insertion/fixture.urdf']}```

###
```python
import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class ColorOrderedInsertionNew(Task):
    """"""Insert differently-colored ell objects into the matching color fixture in a specific order.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""put the {color} L shape block in the L shape hole""
        self.task_completed_desc = ""done with insertion.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define colors and their order
        colors = ['red', 'blue', 'green', 'yellow']
        color_order = {color: i for i, color in enumerate(colors)}

        # Add fixtures.
        fixture_size = (0.12, 0.12, 0.02)
        fixture_urdf = 'insertion/fixture.urdf'
        fixtures = []
        for color in colors:
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=utils.COLORS[color], category='fixed')
            fixtures.append(fixture_id)

        # Add ell objects.
        ell_size = (0.04, 0.04, 0.04)
        ell_urdf = 'insertion/ell.urdf'
        ells = []
        for color in colors:
            ell_pose = self.get_random_pose(env, ell_size)
            ell_id = env.add_object(ell_urdf, ell_pose, color=utils.COLORS[color])
            ells.append(ell_id)

        # Goal: each ell is inserted into the matching color fixture in the correct order.
        for i, ell in enumerate(ells):
            self.add_goal(objs=[ell], matches=np.ones((1, 1)), targ_poses=[p.getBasePositionAndOrientation(fixtures[i])], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(ells),
                          language_goal=self.lang_template.format(color=colors[i]))
```

###"
"Write the pybullet simulation code for the task ""put-blocks-between-zones"" in a python code block.
###

"," 
 put-blocks-between-zones: {'task-name': 'put-blocks-between-zones', 'task-description': 'Arrange four differently colored blocks (red, blue, green, and yellow) between two designated zones on the tabletop.', 'assets-used': ['zone/zone.urdf', 'block/block.urdf']}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import copy

class PutBlocksBetweenZones(Task):
    """"""Arrange four differently colored blocks (red, blue, green, and yellow) between two designated zones on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""Arrange the blocks between the zones in the order: red, blue, green, yellow""
        self.task_completed_desc = ""done arranging blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zones.
        zone_size = (0.12, 0.12, 0)
        zone_urdf = 'zone/zone.urdf'
        zone1_pose = self.get_random_pose(env, zone_size)
        zone2_pose = copy.deepcopy(zone1_pose)
        zone2_pose = (utils.apply(zone1_pose, (0,0.1,0)), zone2_pose[1])
        env.add_object(zone_urdf, zone1_pose, 'fixed')
        env.add_object(zone_urdf, zone2_pose, 'fixed')

        # Block colors.
        colors = [
            utils.COLORS['red'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        for i in range(4):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            blocks.append(block_id)

        # Goal: blocks are arranged between the zones in the order: red, blue, green, yellow.
        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, 0.1, 0.03)]
        targs = [(utils.apply(zone1_pose, i), zone1_pose[1]) for i in place_pos]

        # Add goal
        self.add_goal(objs=blocks, matches=np.ones((4, 4)), targ_poses=targs, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, symmetries=[np.pi/2]*4, language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""put-blues-around-red"" in a python code block.
###

"," 
 put-blues-around-red: {'task-name': 'put-blues-around-red', 'task-description': 'place the blue blocks around the red block.', 'assets-used': ['block/block_for_anchors.urdf']}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PlaceBluesAroundRed(Task):
    """"""Pick up the blue blocks one by one and place them around the red block, forming a circle.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the blue blocks around the red block""
        self.task_completed_desc = ""done placing blue blocks around red block.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add red block.
        red_block_size = (0.04, 0.04, 0.04)
        red_block_urdf = 'block/block_for_anchors.urdf'
        red_block_pose = self.get_random_pose(env, red_block_size)
        red_block_id = env.add_object(red_block_urdf, red_block_pose, 'fixed')

        # Add blue blocks.
        blue_blocks = []
        blue_block_size = (0.02, 0.02, 0.02)
        blue_block_urdf = 'block/block_for_anchors.urdf'
        N = 4

        for _ in range(N):
            blue_block_pose = self.get_random_pose(env, blue_block_size)
            blue_block_id = env.add_object(blue_block_urdf, blue_block_pose, color=utils.COLORS['blue'])
            blue_blocks.append(blue_block_id)

        # Calculate target poses for blue blocks to form a circle around the red block.
        radius = 0.06  # radius of the circle
        angles = np.linspace(0, 2*np.pi, N, endpoint=False)  # angles for each blue block
        targ_poses = []
        for angle in angles:
            x = red_block_pose[0][0] + radius * np.cos(angle)
            y = red_block_pose[0][1] + radius * np.sin(angle)
            z = red_block_pose[0][2]
            targ_poses.append(((x, y, z), red_block_pose[1]))

            # Add goal.
            self.add_goal(objs=blue_blocks, matches=np.eye(N), targ_poses=targ_poses, replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1., language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""place-blue-on-line-ends"" in a python code block.
###

"," 
 place-blue-on-line-ends: {'task-name': 'place-blue-on-line-ends', 'task-description': 'Pick up each blue box and accurately place it at the end of a green line.', 'assets-used': ['line/line-template.urdf', 'box/box-template.urdf']}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class PlaceBlueOnLineEnds(Task):
    """"""Pick up each blue box and accurately place it at the end of a green line.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""place the blue box at the end of the green line""
        self.task_completed_desc = ""done placing blue boxes on line ends.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add lines.
        line_size = (0.3, 0.01, 0.01)
        line_template = 'line/line-template.urdf'
        replace = {'DIM': line_size}
        line_urdf = self.fill_template(line_template, replace)

        line_colors = ['green']
        line_poses = []

        line_pose = self.get_random_pose(env, line_size)
        color = utils.COLORS[line_colors[0]]
        env.add_object(line_urdf, line_pose, 'fixed', color=color)
        line_poses.append(utils.apply(line_pose, (-0.15,0,0)))
        line_poses.append(utils.apply(line_pose, (0.15,0,0)))

        # Add blue boxes.
        box_size = (0.04, 0.04, 0.04)
        box_urdf = 'box/box-template.urdf'
        box_color = utils.COLORS['blue']
        boxes = []
        for _ in range(2):
            box_pose = self.get_random_pose(env, box_size)
            box_id = env.add_object(box_urdf, box_pose, color=box_color)
            boxes.append(box_id)

        # Goal: each blue box is at the end of a different colored line.
        for i in range(2):
            language_goal = self.lang_template.format(line_colors[0])
            self.add_goal(objs=[boxes[i]], matches=np.ones((1, 1)), targ_poses=[line_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 2, language_goal=language_goal)

```

###"
"Write the pybullet simulation code for the task ""stack-three-layer-red-wall"" in a python code block.
###

"," 
 stack-three-layer-red-wall: {'task-name': 'block-on-cylinder-on-pallet', 'task-description': 'On the tabletop, there are three cylinders of different colors (red, blue, and green) and three blocks of the same colors. The task involves picking up each block and placing it on the corresponding colored cylinder, which are located in specific positions on a pallet. Starting with the red block and cylinder, followed by blue and finally green. The challenge lies in the precise placement of the blocks on the cylinders, while maintaining color coordination.', 'assets-used': ['block/block.urdf', 'cylinder/cylinder-template.urdf', 'pallet/pallet.urdf']}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class StackThreeLayerRedWall(Task):
    """"""Build a wall by stacking blocks. The wall should consist of three layers with each layer having three red blocks aligned in a straight line.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""stack the red blocks to form a three-layer wall""
        self.task_completed_desc = ""done stacking blocks.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add blocks.
        block_size = (0.05, 0.05, 0.03)  # x, y, z dimensions for the block size
        block_urdf = 'block/block_for_anchors.urdf'  # URDF for the block
        block_color = utils.COLORS['red']  # Color for the block

        # We need 9 blocks for a three-layer wall with each layer having three blocks.
        blocks = []
        for _ in range(9):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

        # Define target poses for the blocks to form a three-layer wall.
        # The target poses are defined relative to a base pose.
        base_pose = ((0.5, 0.0, 0.0), (0, 0, 0, 1))
        target_poses = []
        for i in range(3):  # three layers
            for j in range(3):  # three blocks per layer
                target_pos = (j * block_size[0], 0, i * block_size[2])
                target_pose = (utils.apply(base_pose, target_pos), (0, 0, 0, 1))
                target_poses.append(target_pose)

            # Goal: all blocks are stacked to form a three-layer wall.
            self.add_goal(objs=blocks[3*i:3*(i+1)], matches=np.ones((3, 3)), targ_poses=target_poses[3*i:3*(i+1)], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / 3., language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""block-on-cylinder-on-pallet"" in a python code block.
###

"," 
 block-on-cylinder-on-pallet: {'task-name': 'block-on-cylinder-on-pallet', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'block/block.urdf'], 'task-description': 'Pick up each block and place it on the corresponding colored cylinder, which are located in specific positions on a pallet.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BlockOnCylinderOnPallet(Task):
    """"""Pick up each block and place it on the corresponding colored cylinder, which are located in specific positions on a pallet.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {} cylinder on the pallet""
        self.lang_template_2 = ""place the {} block on the {} cylinder""

        self.task_completed_desc = ""done placing blocks on cylinders and cylinder on pallet.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add pallet.
        pallet_size = (0.35, 0.35, 0.01)
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define colors.
        block_colors = ['red']
        cylinder_colors = ['blue']

        # Add cylinders.
        cylinder_size = (0.04, 0.04, 0.06)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []


        replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2), 'COLOR': block_colors[0]}
        cylinder_urdf = self.fill_template(cylinder_template, replace)
        cylinder_pose = self.get_random_pose(env, cylinder_size)
        cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
        cylinders.append(cylinder_id)

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'block/block.urdf'
        blocks = []
        block_pose = self.get_random_pose(env, block_size)
        block_id = env.add_object(block_urdf, block_pose, color=cylinder_colors[0])
        blocks.append(block_id)

        # Goal: place the cylinder on top of the pallet
        self.add_goal(objs=[cylinders[0]], matches=np.ones((1, 1)), targ_poses=[pallet_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=self.lang_template.format(cylinder_colors[0]))


        # Goal: place the block on top of the cylinder
        language_goal = self.lang_template_2.format(block_colors[0], cylinder_colors[0])
        self.add_goal(objs=[blocks[0]], matches=np.ones((1, 1)), targ_poses=[pallet_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=language_goal)

```

###"
"Write the pybullet simulation code for the task ""ball-on-box-on-container"" in a python code block.
###

"," 
 ball-on-box-on-container: {'task-name': 'ball-on-box-on-container', 'assets-used': ['container/container-template.urdf', 'box/box-template.urdf', 'ball/ball.urdf'], 'task-description': 'Pick up each ball and place it on the corresponding colored box, which are located in specific positions on a container.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils

class BallOnBoxOnContainer(Task):
    """"""Pick up each ball and place it on the corresponding colored box, which are located in specific positions on a container.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {} box on the container""
        self.lang_template_2 = ""place the {} ball on the {} box""

        self.task_completed_desc = ""done placing balls on boxs and box on container.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add container.
        container_size = (0.2, 0.2, 0.06)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)

        env.add_object(container_urdf, container_pose, 'fixed')

        # Define colors.
        ball_colors = ['red']
        box_colors = ['blue']

        # Add boxs.
        box_size = (0.04, 0.04, 0.06)
        box_template = 'box/box-template.urdf'
        boxs = []


        replace = {'DIM': box_size, 'HALF': (box_size[0] / 2, box_size[1] / 2, box_size[2] / 2), 'COLOR': ball_colors[0]}
        box_urdf = self.fill_template(box_template, replace)
        box_pose = self.get_random_pose(env, box_size)
        box_id = env.add_object(box_urdf, box_pose)
        boxs.append(box_id)

        # Add balls.
        ball_size = (0.04, 0.04, 0.04)
        ball_urdf = 'ball/ball.urdf'
        balls = []
        ball_pose = self.get_random_pose(env, ball_size)
        ball_id = env.add_object(ball_urdf, ball_pose, color=box_colors[0])
        balls.append(ball_id)

        # Goal: place the box on top of the container
        self.add_goal(objs=[boxs[0]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=self.lang_template.format(box_colors[0]))


        # Goal: place the ball on top of the box
        language_goal = self.lang_template_2.format(ball_colors[0], box_colors[0])
        self.add_goal(objs=[balls[0]], matches=np.ones((1, 1)), targ_poses=[container_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=language_goal)

```

###"
"Write the pybullet simulation code for the task ""align-rope-along-line"" in a python code block.
###

"," 
 align-rope-along-line: {'task-name': 'align-rope-along-line', 'assets-used': ['line/line-template.urdf'], 'task-description': 'Align a deformable rope along a straight line marked on the tabletop.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class AlignRopeAlongLine(Task):
    """"""Align a deformable rope along a straight line marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope along the line""
        self.task_completed_desc = ""done aligning.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add line.
        length = np.random.uniform(0.18, 0.25)
        line_size = (length, 0.01, 0.01)
        line_pose = self.get_random_pose(env, line_size)
        line_template = 'line/line-template.urdf'
        replace = {'DIM': line_size, 'HALF': (line_size[0] / 2, line_size[1] / 2, line_size[2] / 2)}
        line_urdf = self.fill_template(line_template, replace)
        env.add_object(line_urdf, line_pose, 'fixed')

        # Add rope.
        rope_size  = (length, 0.01, 0.01)
        rope_pose = self.get_random_pose(env, rope_size)
        corner1_pose = utils.apply(line_pose, (length / 2, 0.01, 0.01))
        corner2_pose = utils.apply(line_pose, (-length / 2, 0.01, 0.01))
        rope_id, targets, matches = self.make_rope(env, (corner1_pose, corner2_pose), n_parts=15)

        # Goal: rope is aligned with the line.
        self.add_goal(objs=rope_id, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""align-rope-cross-zone"" in a python code block.
###

"," 
 align-rope-cross-zone: {'task-name': 'align-rope-cross-zone', 'assets-used': ['zone/zone.urdf'], 'task-description': 'Align a deformable rope across the diagonal of a zone marked on the tabletop.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula

class AlignRopeCrossZone(Task):
    """"""Align a deformable rope across the diagonal of a zone marked on the tabletop.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = ""align the rope across the diagonal of a zone""
        self.task_completed_desc = ""done aligning.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zone.
        length = 0.12
        zone_size = (length, length, 0.01)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add rope.
        rope_size  = (length, 0.01, 0.01)
        rope_pose = self.get_random_pose(env, rope_size)
        corner1_pose = utils.apply(zone_pose, (length / 2, length / 2, 0.01))
        corner2_pose = utils.apply(zone_pose, (-length / 2, -length / 2, 0.01))
        rope_id, targets, matches = self.make_rope(env, (corner1_pose, corner2_pose), n_parts=10)

        # Goal: rope is aligned with the diagonal of the zone.
        self.add_goal(objs=rope_id, matches=matches, targ_poses=targets, replace=False,
                rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

```

###"
"Write the pybullet simulation code for the task ""put-kit-in-bowl"" in a python code block.
###

"," 
 put-kit-in-bowl: {'task-name': 'put-kit-in-bowl', 'assets-used': ['stacking/block.urdf', 'bowl/bowl.urdf', 'kitting/object-template.urdf'], 'task-description': 'Place the specific kit in a bowl of specified color.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os


class PutKitInBowl(Task):
    """"""Place the specific kit in a bowl of specified color.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} in a {place} bowl""
        self.task_completed_desc = ""done placing kit in bowls.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_objects = np.random.randint(1, n_bowls + 1)
        colors, selected_color_names = utils.get_colors(mode=self.mode, n_colors=2)
        block_urdf = 'stacking/block.urdf'
        block_size = (0.04, 0.04, 0.04)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, category='fixed', color=colors[1])
            bowl_poses.append(bowl_pose)

        # Add kits.
        objects_ids = []
        obj_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_objects):
            scale = utils.map_kit_scale((0.03, 0.03, 0.02))
            shape = os.path.join(self.assets_root, 'kitting',
                                     f'{obj_shapes[i]:02d}.obj')
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[0]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            obj_pose = self.get_random_pose(env, block_size)
            obj_id = env.add_object(urdf, obj_pose)
            objects_ids.append(obj_id)

            # Goal: put each block in a different bowl.
            pick_name = selected_color_names[0] + "" "" + utils.assembling_kit_shapes[obj_shapes[i]]
            language_goal = (self.lang_template.format(pick=pick_name, place=selected_color_names[1]))
            self.add_goal(objs=[obj_id], matches=np.ones((1, 1)), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

        # Only one mistake allowed.
        self.max_steps = len(objects_ids) + 1

        # Colors of distractor objects.
        distractor_bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c not in selected_color_names]
        distractor_block_colors = [utils.COLORS[c] for c in utils.COLORS if c not in selected_color_names]

        # Add distractors.
        n_distractors = 0
        max_distractors = 6
        while n_distractors < max_distractors:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = distractor_block_colors if is_block else distractor_bowl_colors
            pose = self.get_random_pose(env, size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
```

###"
"Write the pybullet simulation code for the task ""kit-in-bowl-in-zone"" in a python code block.
###

"," 
 kit-in-bowl-in-zone: {'task-name': 'kit-in-bowl-in-zone', 'assets-used': ['zone/zone.urdf', 'bowl/bowl.urdf', 'kitting/object-template.urdf'], 'task-description': 'Pick up each kit and place it on the corresponding colored bowl, which are located in specific positions on a zone.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import os

class KitInBowlInZone(Task):
    """"""Pick up each kit and place it on the corresponding colored bowl, which are located in specific positions on a zone.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 15
        self.lang_template = ""place the {} bowl on the zone""
        self.lang_template_2 = ""place the {} on the {} bowl""

        self.task_completed_desc = ""done placing kits on bowls and bowl on zone.""
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add zone.
        zone_size = (0.2, 0.2, 0.01)
        zone_pose = self.get_random_pose(env, zone_size)
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Define colors.
        kit_colors = ['red']
        bowl_colors = ['blue']

        # Add bowls.
        bowl_size = (0.04, 0.04, 0.06)
        bowls = []
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_id = env.add_object(bowl_urdf, bowl_pose)
        bowls.append(bowl_id)

        # Add kits.
        kit_size = utils.map_kit_scale((0.03, 0.03, 0.02))
        obj_shapes = self.get_kitting_shapes(1)
        shape = os.path.join(self.assets_root, 'kitting',
                                 f'{obj_shapes[0]:02d}.obj')
        template = 'kitting/object-template.urdf'
        replace = {'FNAME': (shape,), 'SCALE': kit_size, 'COLOR': kit_colors[0]}

        # IMPORTANT: REPLACE THE TEMPLATE URDF
        kit_urdf = self.fill_template(template, replace)
        kits = []
        kit_pose = self.get_random_pose(env, kit_size)
        kit_id = env.add_object(kit_urdf, kit_pose, color=bowl_colors[0])
        kits.append(kit_id)

        # Goal: place the bowl on top of the zone
        self.add_goal(objs=[bowls[0]], matches=np.ones((1, 1)), targ_poses=[zone_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=self.lang_template.format(bowl_colors[0]))


        # Goal: place the kit on top of the bowl
        pick_name = kit_colors[0] + "" "" + utils.assembling_kit_shapes[obj_shapes[0]]
        language_goal = self.lang_template_2.format(pick_name, bowl_colors[0])
        self.add_goal(objs=[kits[0]], matches=np.ones((1, 1)), targ_poses=[zone_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/2, language_goal=language_goal)

```

###"
"Write the pybullet simulation code for the task ""move-kit-from-zone-to-cylinder"" in a python code block.
###

"," 
 move-kit-from-zone-to-cylinder: {'task-name': 'move-kit-from-zone-to-cylinder', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf', 'kitting/object-template.urdf', 'kitting/object-template.urdf'], 'task-description': 'Place the specific kit from a zone to a cylinder.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os
import copy

class MoveKitFromZoneToCylinder(Task):
    """"""Place the specific kit from a zone to a cylinder.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} from zone to {place} cylinder.""
        self.task_completed_desc = ""done placing kit in zones.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_zones = 3
        n_objects = 3
        colors, color_names = utils.get_colors(mode=self.mode, n_colors=n_objects)

        # Add zones and objects
        # x, y, z dimensions for the asset size
        cylinder_size = (0.12, 0.12, 0)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []

        zone_size = (0.06, 0.06, 0)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        objects_ids = []
        obj_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_zones):
            # add zone
            zone_pose = self.get_random_pose(env, zone_size)
            zone_id = env.add_object(zone_urdf, zone_pose, category='fixed', color=colors[i])
            zone_poses.append(zone_pose)

            # add kit
            scale = utils.map_kit_scale((0.03, 0.03, 0.02))
            shape = os.path.join(self.assets_root, 'kitting',
                                     f'{obj_shapes[i]:02d}.obj')
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            obj_pose = zone_pose
            obj_id = env.add_object(urdf, obj_pose)
            objects_ids.append(obj_id)

            # add cylinder
            cylinder_pose = self.get_random_pose(env, zone_size)
            template = 'kitting/object-template.urdf'
            replace = {'FNAME': (shape,), 'SCALE': scale, 'COLOR': colors[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, category='fixed', color=colors[i])
            cylinder_poses.append(cylinder_pose)

        # Goal: put a specific kit from a zone to the top of a cylinder
        target_idx = np.random.randint(n_zones)
        pick_name = color_names[target_idx] + "" "" + utils.assembling_kit_shapes[obj_shapes[target_idx]]
        language_goal = (self.lang_template.format(pick=pick_name, place=color_names[target_idx]))
        self.add_goal(objs=[objects_ids[target_idx]], matches=np.ones((1, 1)), targ_poses=[cylinder_poses[target_idx]], replace=False,
            rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

```

###"
"Write the pybullet simulation code for the task ""move-bowl-from-pallet-to-corner"" in a python code block.
###

"," 
 move-bowl-from-pallet-to-corner: {'task-name': 'move-bowl-from-pallet-to-corner', 'assets-used': ['corner/corner-template.urdf', 'pallet/pallet.urdf', 'bowl/bowl.urdf'], 'task-description': 'Place the specific bowl from a pallet to a corner.'}```

###
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import random
import pybullet as p
import os
import copy

class MoveBowlFromPalletToCorner(Task):
    """"""Place the specific bowl from a pallet to a corner.""""""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = ""put the {pick} from pallet to {place} corner.""
        self.task_completed_desc = ""done placing bowl around corner.""
        self.additional_reset()


    def reset(self, env):
        super().reset(env)
        n_pallets = 3
        n_objects = 3
        colors, color_names = utils.get_colors(mode=self.mode, n_colors=n_objects)
        # Add pallets and objects
        # x, y, z dimensions for the asset size
        corner_size = (0.12, 0.12, 0)
        corner_urdf = 'corner/corner-template.urdf'
        corner_poses = []

        pallet_size = (0.06, 0.06, 0)
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_poses = []
        objects_ids = []
        bowl_shapes = self.get_kitting_shapes(n_objects)

        for i in range(n_pallets):
            # add pallet
            pallet_pose = self.get_random_pose(env, pallet_size)
            pallet_id = env.add_object(pallet_urdf, pallet_pose, category='fixed', color=colors[i])
            pallet_poses.append(pallet_pose)

            # add kit
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_pose = pallet_pose
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=colors[i])
            objects_ids.append(bowl_id)

            # add corner
            corner_pose = self.get_random_pose(env, pallet_size)
            corner_id = env.add_object(corner_urdf, corner_pose, category='fixed', color=colors[i])
            corner_poses.append(corner_pose)

        # Goal: put a specific kit from a pallet to the top of a corner
        target_idx = np.random.randint(n_pallets)
        pick_name = color_names[target_idx] + "" "" + 'bowl'
        language_goal = (self.lang_template.format(pick=pick_name, place=color_names[target_idx]))
        self.add_goal(objs=[objects_ids[target_idx]], matches=np.ones((1, 1)), targ_poses=[corner_poses[target_idx]], replace=False,
            rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects, language_goal=language_goal)

```

###"
